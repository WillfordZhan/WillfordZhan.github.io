<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>纯 Java AI vs Java MCP + Python Control Plane：重构方案与落地模块解析</title>
    <link href="/2026/02/20/java-ai-vs-java-mcp-python-control-plane/"/>
    <url>/2026/02/20/java-ai-vs-java-mcp-python-control-plane/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>第一版 AI 能力是典型的纯 Java 单体实现：请求进入 Java Web 层后，直接在同一进程内完成模型调用、工具路由、业务执行与响应拼装。这个方案早期上线快，但随着需求从「能用」走向「可控、可观测、可扩展」，问题开始集中暴露：</p><ol><li>推理编排和业务工具耦合，修改工具策略会影响主链路稳定性。</li><li>流式输出与长任务状态管理能力弱，<code>run</code> 生命周期缺少统一抽象。</li><li>多工具权限控制分散在业务代码里，审计链路不完整。</li><li>Java 侧迭代成本高，难以快速试验 Agent 策略和协议演进。</li></ol><p>因此本次重构目标不是简单“拆服务”，而是明确控制平面与执行平面的边界：<strong>Java 负责工具执行的稳定性与治理；Python 负责运行编排与流式交互体验</strong>。</p><h2 id="现状：纯-Java-AI-实现的结构与瓶颈"><a href="#现状：纯-Java-AI-实现的结构与瓶颈" class="headerlink" title="现状：纯 Java AI 实现的结构与瓶颈"></a>现状：纯 Java AI 实现的结构与瓶颈</h2><p>当前纯 Java 方案的主流程可以抽象为：</p><p><code>HTTP 请求 -&gt; Java Controller -&gt; Prompt/Tool 组装 -&gt; 模型调用 -&gt; 工具执行 -&gt; 返回结果</code></p><p>这个流程的问题不在“能否跑通”，而在于以下三个工程属性不足：</p><ol><li>生命周期治理不足：缺少 <code>run</code> 级状态机，失败恢复、断线重连、事件重放困难。</li><li>观测粒度不足：日志多为文本级，缺少标准化 <code>tool_call/tool_result</code> 事件和 trace 关联。</li><li>协议演进困难：工具调用协议与 Java 内部对象绑定，跨语言复用成本高。</li></ol><h2 id="关键差异对比表"><a href="#关键差异对比表" class="headerlink" title="关键差异对比表"></a>关键差异对比表</h2><table><thead><tr><th>维度</th><th>纯 Java AI（当前）</th><th>Java MCP + Python Control Plane（目标）</th><th>关键收益</th></tr></thead><tbody><tr><td>架构边界</td><td>编排与执行同进程</td><td>控制平面与执行平面分离</td><td>解耦迭代节奏</td></tr><tr><td>工具协议</td><td>内部对象&#x2F;方法调用为主</td><td>统一 MCP 协议 + tool registry</td><td>跨语言一致性</td></tr><tr><td>运行模型</td><td>请求级同步思维</td><td><code>run</code> 异步生命周期 + SSE 事件流</td><td>可恢复、可追踪</td></tr><tr><td>权限治理</td><td>业务代码内零散校验</td><td><code>authz-lite</code> 前置校验</td><td>风险收敛到入口</td></tr><tr><td>可观测性</td><td>文本日志为主</td><td>标准事件 + <code>ai.tool.invoke</code> 结构化日志</td><td>排障效率提升</td></tr><tr><td>扩展路径</td><td>增加工具需改主流程</td><td>registry 注册 + dispatcher 分发</td><td>新工具接入更快</td></tr><tr><td>失败处理</td><td>失败点分散</td><td>run 状态机 + 可回放事件流</td><td>故障定位更确定</td></tr><tr><td>研发效率</td><td>Java 改动链路长</td><td>Python 快速试验，Java 保持稳定内核</td><td>试验速度与稳定性兼得</td></tr></tbody></table><h2 id="目标架构图（文字图）"><a href="#目标架构图（文字图）" class="headerlink" title="目标架构图（文字图）"></a>目标架构图（文字图）</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs text">[Client/UI]<br>   |<br>   | HTTP POST /ai/runs<br>   v<br>[Python Control Plane]<br>  - Run API (/ai/runs)<br>  - Orchestrator (plan/step/retry)<br>  - SSE Stream (/ai/runs/&#123;id&#125;/events)<br>  - MCP Client<br>   |<br>   | MCP tool call<br>   v<br>[Java MCP Server]<br>  - MCP Entry<br>  - Tool Registry<br>  - Authz-lite<br>  - Dispatcher<br>  - Tool Adapters (domain services)<br>   |<br>   v<br>[Business Systems / DB / Device APIs]<br></code></pre></td></tr></table></figure><h2 id="调用链设计（端到端）"><a href="#调用链设计（端到端）" class="headerlink" title="调用链设计（端到端）"></a>调用链设计（端到端）</h2><ol><li>客户端提交问题到 Python <code>POST /ai/runs</code>，返回 <code>runId</code>（异步）。</li><li>Orchestrator 创建步骤并触发模型推理，决定是否调用工具。</li><li>若需工具，MCP Client 发起标准化 <code>tool_call</code> 到 Java MCP 入口。</li><li>Java 侧经 <code>registry -&gt; authz-lite -&gt; dispatcher</code> 找到目标工具并执行。</li><li>Java 产出 <code>ai.tool.invoke</code> 结构化日志与工具结果，返回 MCP 响应。</li><li>Python 将 <code>tool_result</code> 写入运行上下文，继续下一步推理。</li><li>SSE 端持续推送 <code>run_started / step / tool_call / tool_result / completed|failed</code>。</li></ol><p>这条调用链的关键是：<strong>控制平面只做编排，不承载业务副作用；执行平面只做可治理的工具执行，不绑推理策略。</strong></p><h2 id="模块拆分与职责"><a href="#模块拆分与职责" class="headerlink" title="模块拆分与职责"></a>模块拆分与职责</h2><h3 id="Java-侧（执行平面）"><a href="#Java-侧（执行平面）" class="headerlink" title="Java 侧（执行平面）"></a>Java 侧（执行平面）</h3><ol><li><code>mcp-entry</code>：协议入口、请求反序列化、trace 透传。</li><li><code>tool-registry</code>：工具元数据与 handler 注册，支持动态发现或配置注册。</li><li><code>authz-lite</code>：轻量权限校验（租户、角色、工具级 allowlist）。</li><li><code>dispatcher</code>：统一分发、超时控制、错误码标准化。</li><li><code>ai.tool.invoke</code> 日志：记录 <code>runId/toolName/argsDigest/latency/resultCode</code>，支持审计与性能分析。</li></ol><h3 id="Python-侧（控制平面）"><a href="#Python-侧（控制平面）" class="headerlink" title="Python 侧（控制平面）"></a>Python 侧（控制平面）</h3><ol><li><code>/ai/runs</code>：异步创建运行，立即返回 <code>runId</code>。</li><li><code>/ai/runs/&#123;runId&#125;/events</code>：SSE 事件流，支持重连后的 replay + tail。</li><li><code>orchestrator</code>：步骤状态机、重试策略、工具调用决策。</li><li><code>mcp-client</code>：与 Java MCP 协议通信、异常映射、幂等请求头传递。</li></ol><h2 id="已落地模块（本次盘点）"><a href="#已落地模块（本次盘点）" class="headerlink" title="已落地模块（本次盘点）"></a>已落地模块（本次盘点）</h2><p>目前已经看到并可归类为“已落地”的能力有：</p><ol><li>Java MCP 入口层（可接收 MCP tool 调用）。</li><li>Java tool registry（工具注册与查找能力）。</li><li>Java <code>authz-lite</code>（轻量授权校验链路）。</li><li>Java dispatcher（统一调度与执行入口）。</li><li>Java <code>ai.tool.invoke</code> 日志（工具调用审计关键埋点）。</li><li>Python <code>/ai/runs</code> + SSE 事件流接口骨架。</li><li>Python MCP client（控制平面到执行平面的协议桥接）。</li></ol><p>这意味着架构重构不是“纸面设计”，而是已经完成了核心骨架打通，后续重点转向稳定性与规范化。</p><h2 id="实施计划（阶段里程碑）"><a href="#实施计划（阶段里程碑）" class="headerlink" title="实施计划（阶段里程碑）"></a>实施计划（阶段里程碑）</h2><h3 id="Phase-1：协议与入口固化（已完成主体）"><a href="#Phase-1：协议与入口固化（已完成主体）" class="headerlink" title="Phase 1：协议与入口固化（已完成主体）"></a>Phase 1：协议与入口固化（已完成主体）</h3><p>目标：打通 Python -&gt; Java MCP 的最小闭环。<br>里程碑：</p><ol><li><code>POST /ai/runs</code> 创建 run。</li><li>Java MCP 入口可执行至少一个真实工具。</li><li>SSE 能看到 <code>tool_call/tool_result</code> 基础事件。</li></ol><h3 id="Phase-2：治理能力补齐"><a href="#Phase-2：治理能力补齐" class="headerlink" title="Phase 2：治理能力补齐"></a>Phase 2：治理能力补齐</h3><p>目标：把“能跑”升级为“可控”。<br>里程碑：</p><ol><li><code>authz-lite</code> 从静态规则升级到可配置策略。</li><li>dispatcher 增加超时分级与熔断隔离。</li><li><code>ai.tool.invoke</code> 接入统一 trace&#x2F;span 关联。</li></ol><h3 id="Phase-3：运行时可靠性"><a href="#Phase-3：运行时可靠性" class="headerlink" title="Phase 3：运行时可靠性"></a>Phase 3：运行时可靠性</h3><p>目标：把“可控”升级为“可恢复”。<br>里程碑：</p><ol><li>run 状态机补齐中断恢复与重试幂等。</li><li>SSE 支持断线续传与游标回放。</li><li>工具失败分类（可重试&#x2F;不可重试&#x2F;需人工干预）。</li></ol><h3 id="Phase-4：规模化扩展"><a href="#Phase-4：规模化扩展" class="headerlink" title="Phase 4：规模化扩展"></a>Phase 4：规模化扩展</h3><p>目标：低成本扩工具与跨团队协作。<br>里程碑：</p><ol><li>工具接入模板化（注册、鉴权、日志、测试用例）。</li><li>多租户策略隔离与限流策略下沉。</li><li>性能基准与容量模型稳定输出。</li></ol><h2 id="验收标准（Definition-of-Done）"><a href="#验收标准（Definition-of-Done）" class="headerlink" title="验收标准（Definition of Done）"></a>验收标准（Definition of Done）</h2><ol><li>功能正确性：核心业务工具在新链路调用成功率 &gt;&#x3D; 99.9%。</li><li>时延目标：P95 工具调用端到端时延 &lt;&#x3D; 800ms（不含大模型本体推理）。</li><li>可观测性：<code>runId</code> 能串联 API 日志、MCP 调用日志、错误事件。</li><li>稳定性：单工具故障不拖垮 run 主链路，错误可降级可回传。</li><li>回归保障：关键工具具备契约测试 + 冒烟测试 + 回滚演练记录。</li></ol><h2 id="面试亮点（架构师视角）"><a href="#面试亮点（架构师视角）" class="headerlink" title="面试亮点（架构师视角）"></a>面试亮点（架构师视角）</h2><ol><li><strong>控制平面&#x2F;执行平面分离</strong>：把“策略迭代快”与“执行稳定”矛盾拆开，组织协作效率显著提升。</li><li><strong>协议先行</strong>：MCP 将工具调用变成标准接口，降低语言与团队边界摩擦。</li><li><strong>run 生命周期建模</strong>：从“请求响应”升级到“可追踪任务”，天然支持 SSE、重放、恢复。</li><li><strong>治理内建而非补丁</strong>：<code>authz-lite + dispatcher + ai.tool.invoke</code> 在入口前置，风险可控可审计。</li><li><strong>渐进式重构</strong>：先打通骨架，再补治理和可靠性，避免大爆炸式改造风险。</li></ol><h2 id="风险与回滚策略"><a href="#风险与回滚策略" class="headerlink" title="风险与回滚策略"></a>风险与回滚策略</h2><h3 id="主要风险"><a href="#主要风险" class="headerlink" title="主要风险"></a>主要风险</h3><ol><li>双栈复杂度上升：Python 与 Java 边界如果定义不清，会形成新的耦合。</li><li>协议漂移：MCP schema 版本治理缺失会造成灰度失败。</li><li>观测碎片化：日志、事件、trace 口径不一致会影响排障。</li></ol><h3 id="回滚方案"><a href="#回滚方案" class="headerlink" title="回滚方案"></a>回滚方案</h3><ol><li><strong>流量级回滚</strong>：网关开关将特定租户&#x2F;场景切回纯 Java 旧链路。</li><li><strong>能力级回滚</strong>：按工具维度关闭 MCP 路由，仅保留白名单工具走新链路。</li><li><strong>版本级回滚</strong>：保持 Python orchestrator 与 Java MCP 的最近稳定版本镜像，可一键回退。</li><li><strong>数据级保障</strong>：run 事件与日志保留，回滚后仍可复盘失败路径。</li></ol><p>回滚原则：<strong>先止损再定位，先降级再修复</strong>。如果新链路在连续窗口内错误率超阈值（如 5 分钟 &gt; 1%），自动触发降级。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这次重构的价值不只是“多了一个 Python 服务”，而是建立了一个可持续演进的 AI 工程底座：<br>Java 守住执行稳定性与治理边界，Python 承担编排创新与交互体验。<br>在这个边界之上，未来接入更多工具、模型与业务场景都会更可控。</p>]]></content>
    
    
    
    <tags>
      
      <tag>架构设计</tag>
      
      <tag>AI工程</tag>
      
      <tag>MCP</tag>
      
      <tag>Java</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用 iPhone 远程操控 Mac：Termius + Tailscale + tmux（Codex 常驻）</title>
    <link href="/guides/termius-tailscale-tmux/"/>
    <url>/guides/termius-tailscale-tmux/</url>
    
    <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>用 iPhone 的 Termius 远程连接 Mac，借助 Tailscale 组网，实现随时随地安全 SSH；用 tmux 保持会话不断线（适合常驻跑 Codex）。</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ul><li>Termius：iOS SSH 客户端</li><li>Tailscale：内网组网（避免端口映射）</li><li>tmux：会话常驻</li></ul><h2 id="Mac：开启-SSH"><a href="#Mac：开启-SSH" class="headerlink" title="Mac：开启 SSH"></a>Mac：开启 SSH</h2><p>系统设置 → 通用 → 共享 → 远程登录（Remote Login）打开。</p><h2 id="Termius：生成-SSH-Key-并配置"><a href="#Termius：生成-SSH-Key-并配置" class="headerlink" title="Termius：生成 SSH Key 并配置"></a>Termius：生成 SSH Key 并配置</h2><ol><li>Termius → Keychain → + → Generate Key → Ed25519</li><li>复制 Public Key（ssh-ed25519 …）</li><li>Mac 追加到 <code>~/.ssh/authorized_keys</code>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">nano ~/.ssh/authorized_keys<br><span class="hljs-built_in">chmod</span> 700 ~/.ssh<br><span class="hljs-built_in">chmod</span> 600 ~/.ssh/authorized_keys<br></code></pre></td></tr></table></figure><h2 id="Tailscale：同账号组网"><a href="#Tailscale：同账号组网" class="headerlink" title="Tailscale：同账号组网"></a>Tailscale：同账号组网</h2><ul><li>Mac 安装并登录官方 Tailscale.app</li><li>iPhone 安装并登录 Tailscale，开启 VPN</li><li>记下 Mac 的 Tailscale IP（100.x.y.z）或 MagicDNS</li></ul><h2 id="Termius：添加-Host"><a href="#Termius：添加-Host" class="headerlink" title="Termius：添加 Host"></a>Termius：添加 Host</h2><ul><li>Host：Mac 的 100.x 或 MagicDNS</li><li>Port：22</li><li>Username：你的 macOS 用户名</li><li>Auth：选择 Key</li></ul><h2 id="tmux：保持会话"><a href="#tmux：保持会话" class="headerlink" title="tmux：保持会话"></a>tmux：保持会话</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install tmux<br>tmux new -As codex<br></code></pre></td></tr></table></figure><p>常用：<code>Ctrl-b</code> 后按 <code>d</code> 断开但保留会话。</p><h2 id="macOS-权限坑（Desktop：Operation-not-permitted）"><a href="#macOS-权限坑（Desktop：Operation-not-permitted）" class="headerlink" title="macOS 权限坑（Desktop：Operation not permitted）"></a>macOS 权限坑（Desktop：Operation not permitted）</h2><p>如果 SSH 会话访问 <code>~/Desktop</code> 报 <code>Operation not permitted</code>，这是 macOS 隐私保护。</p><ul><li>方案 1（推荐）：把工作目录放到 <code>~/Work</code> 而不是 Desktop</li><li>方案 2：系统设置 → 隐私与安全性 → 完全磁盘访问权限 → 添加 <code>/usr/sbin/sshd</code>，然后重新连接</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>工具技巧</tag>
      
      <tag>远程办公</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于 posthoc_nemenyi_friedman() 函数的一点思考</title>
    <link href="/2019/12/23/Nemenyi/"/>
    <url>/2019/12/23/Nemenyi/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Scikit-posthocs 这个库提供了许多 Post-hoc (后续检验) 的函数，Tukey Post-hoc, Nemenyi Post-hoc 等常见后续测试在这个库里都有相对应的实现，使用起来较为方便。</p><p>最近做的作业中要求使用 Friedman 测试和 Nemenyi 后续测试，来检验三个分类算法的精度是否有较大差异。于是博主使用了 Scikit-posthocs 的 <code>posthoc_nemenyi_friedman()</code> 函数。但在使用过程中我发现这个函数的返回值和我预想中的不一样，它返回了一个所谓的 P-values 矩阵，这个矩阵长这样：</p><img src="/img/nemenyi/006tNbRwgy1ga7dvvelsrj30n80agt9e.jpg" srcset="/img/loading.gif" alt="image-20191223225516040" style="zoom: 50%;" /><p>盲猜矩阵的每个 P-value 是用来和 𝛼 做比较的，但是比较的原则是怎样的呢？这个比较的结果和 Nemenyi 测试结果是怎样关联的呢？</p><p>于是查看了一下这个函数的<a href="https://scikit-posthocs.readthedocs.io/en/latest/generated/scikit_posthocs.posthoc_nemenyi_friedman/" target="_blank" rel="noopener">官方文档</a>，然而文档只说明了函数用法，并没有详细说明函数内部操作的具体流程，无法解除我的疑惑。好在这个库是开源的，于是博主研究了一下这个函数的<a href="https://github.com/maximtrp/scikit-posthocs/blob/master/scikit_posthocs/_posthocs.py" target="_blank" rel="noopener">源码</a>.</p><p>经过博主的一系列研究，最终发现</p><p><strong>这个矩阵中的 P-value 由算法两两比较而产生，用来与 α 做比较，如果 P-value &gt; α，则被比较的两个算法没有明显差异，如果 P-value &lt; α，则被比较的两个算法有明显差异 (Reject H0).</strong></p><p>下面是研究过程：</p><h2 id="Nemenyi-测试"><a href="#Nemenyi-测试" class="headerlink" title="Nemenyi 测试"></a>Nemenyi 测试</h2><p>在解释这个函数的流程之前，我们必须先熟稔 Nemenyi 测试的流程</p><p>根据西瓜书上的说明，Friedman 测试结果如果表明 “算法性能显著不同”，则需进行 Nemenyi 后续测试。书上所描述的 Nemenyi 测试流程是这样的:</p><ol><li><p>根据公式计算 <strong>Critical Difference (CD)</strong>，<em>q⍺</em> 可查表获得</p><img src="/img/nemenyi/006tNbRwgy1ga77qogt8oj30cs042t8t.jpg" srcset="/img/loading.gif" alt="image-20191223192242846" style="zoom: 50%;" /></li><li><p>将两个算法的平均序值的差 <strong>(Average Rank Difference, ARD)</strong>  和 CD 进行比较，如果 ARD &gt; CD，则两个算法的性能有明显差异。</p></li></ol><h2 id="函数源码解释"><a href="#函数源码解释" class="headerlink" title="函数源码解释"></a>函数源码解释</h2><p>由上述 Nemenyi 测试的解释可得，在西瓜书中， Nemenyi 测试的核心在于计算 CD, 并将其与 ARD 进行比较。然而研究源码之后，博主发现<code>posthoc_nemenyi_friedman()</code>的思路和上述流程迥然不同，十分清奇，值得一看。下面是该函数作者的思路：</p><ol><li><p>在 CD 公式中，由于 <em>k</em> 和 <em>N</em> 是恒定的，因此可知 <em>q⍺</em> 的值决定了 CD 的值，CD 与 <em>q⍺</em> 存在函数映射</p><img src="/img/nemenyi/006tNbRwgy1ga7ao5d5qsj30mk0323yn.jpg" srcset="/img/loading.gif" alt="image-20191223210403181" style="zoom: 67%;" /></li><li><p>由于 ARD 和 CD 是可比较的，意味着 ARD 可化成与 CD 相同的形式。</p></li></ol>   <img src="/img/nemenyi/006tNbRwgy1ga7ap9uxk9j30n202g0sw.jpg" srcset="/img/loading.gif" alt="image-20191223210508251" style="zoom:67%;" /><ol start="3"><li><p>对等式做变换得</p><img src="/img/nemenyi/006tNbRwgy1ga7b0ruy3uj30d203oaa1.jpg" srcset="/img/loading.gif" alt="image-20191223211611760" style="zoom:67%;" /></li><li><p>等式的左边可通过计算得出，将算出的 qβ 值代入<code>自由度 = infinity，样本数 = k的学生化极差分布(Studentized Range)</code>,即可得到 β，β 即为函数返回的 P-value，用于和 α 进行比较</p></li></ol><blockquote><p>西瓜书中解释道 “<em>q⍺</em> 是 Tukey 分布的临界值，在 R 语言中可通过<code>qtukey(1-𝛼, k, Inf) / sqrt(2)</code>计算”。其实就是在自由度 = infinity，样本数 = k ，的学生化极差分布 (Studentized Range) 中取 (1-⍺) 分位数的值，这个在源码中也有所体现。</p></blockquote><h2 id="函数源码"><a href="#函数源码" class="headerlink" title="函数源码"></a>函数源码</h2><p>添加了博主注释的函数源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">posthoc_nemenyi_friedman</span>(<span class="hljs-params">a, y_col=<span class="hljs-literal">None</span>, block_col=<span class="hljs-literal">None</span>, group_col=<span class="hljs-literal">None</span>, melted=<span class="hljs-literal">False</span>, sort=<span class="hljs-literal">False</span></span>):<br>    <span class="hljs-comment"># 计算 q-value 可理解为 qβ，和公式中的 q⍺ 对应</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">compare_stats</span>(<span class="hljs-params">i, j</span>):<br>        dif = np.<span class="hljs-built_in">abs</span>(R[groups[i]] - R[groups[j]])<br>        <span class="hljs-comment"># qβ = ARD / 公式中带根号的部分</span><br>        qval = dif / np.sqrt(k * (k + <span class="hljs-number">1.</span>) / (<span class="hljs-number">6.</span> * n))<br>        <span class="hljs-keyword">return</span> qval<br><br>    <span class="hljs-comment"># 将输入的矩阵转换为该库中定义的 block 格式</span><br>    x, _y_col, _group_col, _block_col = __convert_to_block_df(a, y_col, group_col, block_col, melted)<br>    x.sort_values(by=[_group_col, _block_col], ascending=<span class="hljs-literal">True</span>, inplace=<span class="hljs-literal">True</span>)<br>    x.dropna(inplace=<span class="hljs-literal">True</span>)<br><br>    groups = x[_group_col].unique()<br>    k = groups.size<br>    n = x[_block_col].unique().size<br><br>    x[<span class="hljs-string">&#x27;mat&#x27;</span>] = x.groupby(_block_col)[_y_col].rank()<br>    R = x.groupby(_group_col)[<span class="hljs-string">&#x27;mat&#x27;</span>].mean()<br><br>    vs = np.zeros((k, k))<br>    <span class="hljs-comment"># 原矩阵的列数（用于比较的算法个数）为 k</span><br>    <span class="hljs-comment"># 生成 k * k 的比较矩阵 M，并将其初始化为零矩阵</span><br>    combs = it.combinations(<span class="hljs-built_in">range</span>(k), <span class="hljs-number">2</span>)<br>    tri_upper = np.triu_indices(vs.shape[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>)<br>    tri_lower = np.tril_indices(vs.shape[<span class="hljs-number">0</span>], -<span class="hljs-number">1</span>)<br><br>    vs[:, :] = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 计算 M 中两两比较的 q-value</span><br>    <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> combs:<br>        vs[i, j] = compare_stats(i, j)<br><br>    vs *= np.sqrt(<span class="hljs-number">2.</span>)<br><br>    <span class="hljs-comment"># 把 qβ 代入到自由度 = infinity，样本数 = k 的 Studentized 分布中，得到 β</span><br>    <span class="hljs-comment"># 由此可以得出 P-value 结果矩阵实际上是算法两两比较，根据公式算出 qβ 里其中的 β 值</span><br>    vs[tri_upper] = psturng(vs[tri_upper], k, np.inf)<br>    vs[tri_lower] = vs.T[tri_lower]<br>    np.fill_diagonal(vs, -<span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">return</span> DataFrame(vs, index=groups, columns=groups)<br></code></pre></td></tr></table></figure><h2 id="函数用法"><a href="#函数用法" class="headerlink" title="函数用法"></a>函数用法</h2><h4 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h4><p><strong>描述：</strong>多个算法在不同数据集上的测试结果 (精度，F1值 …) 所构成的矩阵，例：</p><img src="/img/nemenyi/006tNbRwgy1ga5wpvzuxoj30xw0jawij.jpg" srcset="/img/loading.gif" alt="image-20191222161536827" style="zoom: 33%;" /><p><strong>格式：</strong>一个  <code>Array_like</code> 的数组 (Numpy 数组和二维列表都可以)，或者是 <code>DataFrame</code> 对象，（如果是 <code>DataFrame</code> ，则有更多的相关参数需要输入，详见<a href="https://scikit-posthocs.readthedocs.io/en/latest/generated/scikit_posthocs.posthoc_nemenyi_friedman/" target="_blank" rel="noopener">官方文档</a>）</p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p><strong>描述</strong>：由算法两两对比产生的 P-value <code>DataFrame</code>矩阵，用于与 alpha 进行比较。例：</p><img src="/img/nemenyi/006tNbRwgy1ga7dvvelsrj30n80agt9e.jpg" srcset="/img/loading.gif" alt="image-20191223225516040" style="zoom: 50%;" /><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>上述推导均为博主根据函数写法所得，如有谬误欢迎指证，感激不尽！</p>]]></content>
    
    
    
    <tags>
      
      <tag>知识沉淀</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自用的Mac小技巧</title>
    <link href="/2019/11/16/%25E8%2587%25AA%25E7%2594%25A8%25E7%259A%2584Mac%25E5%25B0%258F%25E6%258A%2580%25E5%25B7%25A7/"/>
    <url>/2019/11/16/%25E8%2587%25AA%25E7%2594%25A8%25E7%259A%2584Mac%25E5%25B0%258F%25E6%258A%2580%25E5%25B7%25A7/</url>
    
    <content type="html"><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h4 id="使用键盘快捷键来快速给文件添加-删除-标签："><a href="#使用键盘快捷键来快速给文件添加-删除-标签：" class="headerlink" title="使用键盘快捷键来快速给文件添加 /删除 标签："></a>使用键盘快捷键来快速给文件添加 /删除 标签：</h4><ul><li>添加标签: 选择文件，然后使用 Control-1 到 Control-7 来添加（或移除）个人收藏标签。</li><li>移除标签: 选择文件，使用 Control-0（零）会移除文件的所有标签。</li></ul><h4 id="设置在终端中启动各种-app-的命令"><a href="#设置在终端中启动各种-app-的命令" class="headerlink" title="设置在终端中启动各种 app 的命令"></a>设置在终端中启动各种 app 的命令</h4><p>以 Typora 为例：</p><ol><li><p>通过添加别名<code>ty</code>来快速启动 Typora。在 <code>~/.bash_profile</code> (这个文件好像要自己建) 中添加 <code>alias ty=&quot;open -a typora&quot;</code></p></li><li><p>添加完成后，执行<code>source ~/.bash_profile</code>(source [executable_file] = ./executable_file ), 就可以在命令行中用 <code>ty [filepath/filename]</code> 以快速用 Typora 打开并编辑文件</p></li></ol><h4 id="文本编辑类"><a href="#文本编辑类" class="headerlink" title="文本编辑类"></a>文本编辑类</h4><ol><li><p><strong>文字退格</strong>： TAB 右移，按 SHIFT+TAB 左移</p></li><li><p><strong>输入 ⍺，β，𝞬 等特殊字符</strong>：用（⌘⌃-Space）呼出 Mac emoji 输入框，搜索 alpha, beta 等想要的字符即可</p></li><li><p><strong>在 word 中输入数学公式</strong>：(‘’⌃’’ + ‘’=’’) 即可呼出word 公式编辑框，输入 LaTeX 公式即可</p></li></ol><h4 id="解决网络端口占用"><a href="#解决网络端口占用" class="headerlink" title="解决网络端口占用"></a>解决网络端口占用</h4><ol><li>查看是占用所需端口的进程：终端输入<code>lsof -i tcp:[port]</code> 将port换成被占用的端口(如：4000)，将会出现占用端口的进程信息。</li></ol><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g917abws8fj30zk02h762.jpg" srcset="/img/loading.gif" alt="查看占用端口的进程"  /><ol start="2"><li>Kill 进程：找到进程的PID,使用kill命令：<code>kill [PID]</code>（进程的PID，如71881），杀死对应的进程，这样所占端口就被释放啦</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>工具技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2019/11/15/hello-world/"/>
    <url>/2019/11/15/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
