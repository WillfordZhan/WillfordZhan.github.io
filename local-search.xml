<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>从零把 uni-app 接到微信开发者工具：HBuilderX 全流程与踩坑复盘</title>
    <link href="/2026/03/02/uni-app-hbuilderx/"/>
    <url>/2026/03/02/uni-app-hbuilderx/</url>
    
    <content type="html"><![CDATA[<p>这篇写给后端同学：不懂前端也能把 <code>uni-app</code> 项目跑到微信开发者工具里预览页面。</p><p>核心结论先说：</p><ul><li><code>uni-app</code> 源码目录不能直接当小程序目录导入微信开发者工具。</li><li>必须先用 HBuilderX 编译，拿到 <code>unpackage/dist/build/mp-weixin</code> 产物。</li><li>再让微信开发者工具打开这个产物目录（或通过 <code>project.config.json</code> 的 <code>miniprogramRoot</code> 指过去）。</li></ul><h2 id="先分清-3-个-appid（这是第一大坑）"><a href="#先分清-3-个-appid（这是第一大坑）" class="headerlink" title="先分清 3 个 appid（这是第一大坑）"></a>先分清 3 个 appid（这是第一大坑）</h2><ol><li>微信小程序 appid（<code>wxa...</code>）<ul><li>用于微信开发者工具和小程序平台。</li></ul></li><li>DCloud appid（<code>__UNI__...</code>）<ul><li>在 <code>manifest.json</code> 里，HBuilderX 编译&#x2F;发行会校验它。</li></ul></li><li>项目目录里的 <code>project.config.json</code> <code>appid</code><ul><li>微信开发者工具读取的配置。</li></ul></li></ol><p>很多报错看起来像“编译问题”，本质是 appid 权限问题。</p><h2 id="最短可跑通流程（推荐）"><a href="#最短可跑通流程（推荐）" class="headerlink" title="最短可跑通流程（推荐）"></a>最短可跑通流程（推荐）</h2><h3 id="1-安装-HBuilderX"><a href="#1-安装-HBuilderX" class="headerlink" title="1) 安装 HBuilderX"></a>1) 安装 HBuilderX</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install --cask hbuilderx<br></code></pre></td></tr></table></figure><h3 id="2-在-HBuilderX-导入项目"><a href="#2-在-HBuilderX-导入项目" class="headerlink" title="2) 在 HBuilderX 导入项目"></a>2) 在 HBuilderX 导入项目</h3><p>打开 HBuilderX，导入 <code>factory-miniprogram</code> 项目根目录。</p><h3 id="3-登录-DCloud-账号，并完成手机号绑定"><a href="#3-登录-DCloud-账号，并完成手机号绑定" class="headerlink" title="3) 登录 DCloud 账号，并完成手机号绑定"></a>3) 登录 DCloud 账号，并完成手机号绑定</h3><p>否则会出现：</p><ul><li><code>此功能需要先登录</code></li><li><code>当前账号尚未绑定手机号</code></li></ul><h3 id="4-在-manifest-json-里确认-DCloud-appid-可用"><a href="#4-在-manifest-json-里确认-DCloud-appid-可用" class="headerlink" title="4) 在 manifest.json 里确认 DCloud appid 可用"></a>4) 在 <code>manifest.json</code> 里确认 DCloud appid 可用</h3><p>如果看到：</p><ul><li><code>您不是这个应用的项目成员</code></li></ul><p>需要在 HBuilderX 的 <code>manifest.json</code> 可视化界面点击“重新获取”，拿到你账号下可用的 <code>__UNI__...</code>。</p><h3 id="5-本地编译到微信小程序（不上传）"><a href="#5-本地编译到微信小程序（不上传）" class="headerlink" title="5) 本地编译到微信小程序（不上传）"></a>5) 本地编译到微信小程序（不上传）</h3><p>可以用 HBuilderX 菜单操作，也可以用 CLI：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">/Applications/HBuilderX.app/Contents/MacOS/cli publish mp-weixin \<br>  --project /你的项目绝对路径/factory-miniprogram \<br>  --name factory-miniprogram \<br>  --appid 你的微信appid \<br>  --upload <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>成功后会看到类似输出：</p><ul><li><code>导出微信小程序成功，路径为：.../unpackage/dist/build/mp-weixin</code></li></ul><h2 id="在微信开发者工具里预览"><a href="#在微信开发者工具里预览" class="headerlink" title="在微信开发者工具里预览"></a>在微信开发者工具里预览</h2><p>目标目录：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">/Users/.../factory-miniprogram/unpackage/dist/build/mp-weixin<br></code></pre></td></tr></table></figure><p>两种方式都行：</p><ol><li>直接在微信开发者工具导入这个目录。</li><li>导入项目根目录，并在 <code>project.config.json</code> 设置：</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;miniprogramRoot&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;unpackage/dist/build/mp-weixin&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;srcMiniprogramRoot&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;unpackage/dist/build/mp-weixin&quot;</span><br></code></pre></td></tr></table></figure><h2 id="这次真实踩坑清单（报错-原因-处理）"><a href="#这次真实踩坑清单（报错-原因-处理）" class="headerlink" title="这次真实踩坑清单（报错 -&gt; 原因 -&gt; 处理）"></a>这次真实踩坑清单（报错 -&gt; 原因 -&gt; 处理）</h2><h3 id="坑-1：app-json-在项目根目录未找到-app-json"><a href="#坑-1：app-json-在项目根目录未找到-app-json" class="headerlink" title="坑 1：app.json: 在项目根目录未找到 app.json"></a>坑 1：<code>app.json: 在项目根目录未找到 app.json</code></h3><ul><li>原因：把 uni-app 源码目录直接当小程序目录导入。</li><li>处理：先编译，导入 <code>unpackage/dist/build/mp-weixin</code>。</li></ul><h3 id="坑-2：component-not-found-u-input"><a href="#坑-2：component-not-found-u-input" class="headerlink" title="坑 2：component not found ... u-input"></a>坑 2：<code>component not found ... u-input</code></h3><ul><li>原因：之前编译不完整&#x2F;失败，<code>uni_modules</code> 没有正确产出。</li><li>处理：修复编译阻塞后重新导出，确认存在：<ul><li><code>unpackage/dist/build/mp-weixin/uni_modules/uview-ui/components/u-input/*</code></li></ul></li></ul><h3 id="坑-3：此功能需要先登录"><a href="#坑-3：此功能需要先登录" class="headerlink" title="坑 3：此功能需要先登录"></a>坑 3：<code>此功能需要先登录</code></h3><ul><li>原因：HBuilderX CLI 的发布能力依赖 DCloud 登录态。</li><li>处理：登录 DCloud 账号。</li></ul><h3 id="坑-4：尚未绑定手机号"><a href="#坑-4：尚未绑定手机号" class="headerlink" title="坑 4：尚未绑定手机号"></a>坑 4：<code>尚未绑定手机号</code></h3><ul><li>原因：账号安全策略限制。</li><li>处理：在 DCloud 用户中心绑定手机号。</li></ul><h3 id="坑-5：您不是这个应用的项目成员"><a href="#坑-5：您不是这个应用的项目成员" class="headerlink" title="坑 5：您不是这个应用的项目成员"></a>坑 5：<code>您不是这个应用的项目成员</code></h3><ul><li>原因：<code>manifest.json</code> 中 <code>__UNI__...</code> 不属于当前账号。</li><li>处理：在 <code>manifest.json</code> 中“重新获取” DCloud appid。</li></ul><h3 id="坑-6：代码使用了-scss-sass-语言，但未安装相应编译器插件"><a href="#坑-6：代码使用了-scss-sass-语言，但未安装相应编译器插件" class="headerlink" title="坑 6：代码使用了 scss/sass 语言，但未安装相应编译器插件"></a>坑 6：<code>代码使用了 scss/sass 语言，但未安装相应编译器插件</code></h3><ul><li>原因：缺少 <code>compile-dart-sass</code> 编译插件。</li><li>处理：安装后重新编译。</li></ul><h3 id="坑-7：微信开发者工具自动拉起失败（IDE-Service-Port）"><a href="#坑-7：微信开发者工具自动拉起失败（IDE-Service-Port）" class="headerlink" title="坑 7：微信开发者工具自动拉起失败（IDE Service Port）"></a>坑 7：微信开发者工具自动拉起失败（IDE Service Port）</h3><ul><li>原因：微信开发者工具 CLI 服务端口未就绪。</li><li>处理：这不影响手动导入预览，直接在微信开发者工具里手动打开产物目录即可。</li></ul><h2 id="给后端同学的“最小心智模型”"><a href="#给后端同学的“最小心智模型”" class="headerlink" title="给后端同学的“最小心智模型”"></a>给后端同学的“最小心智模型”</h2><p>把链路记成 3 步就够了：</p><ol><li><code>uni-app 源码</code>（不能直接预览）</li><li><code>HBuilderX 编译</code>（生成小程序产物）</li><li><code>微信开发者工具打开产物</code></li></ol><p>只要第 2 步成功，前后端联调就能开始。</p><h2 id="建议固定成团队-SOP"><a href="#建议固定成团队-SOP" class="headerlink" title="建议固定成团队 SOP"></a>建议固定成团队 SOP</h2><ol><li>新同学先登录并绑定 DCloud 账号。</li><li>项目初始化第一天就重新获取可用 <code>__UNI__...</code>。</li><li><code>project.config.json</code> 固化 <code>miniprogramRoot</code> 到 <code>unpackage/dist/build/mp-weixin</code>。</li><li>联调前先检查导出目录下是否有：<ul><li><code>app.json</code></li><li><code>uni_modules/uview-ui/components/u-input/*</code></li></ul></li></ol><p>这四条能省掉 80% 的环境问题排查时间。</p>]]></content>
    
    
    
    <tags>
      
      <tag>uni-app</tag>
      
      <tag>微信小程序</tag>
      
      <tag>HBuilderX</tag>
      
      <tag>工程化</tag>
      
      <tag>踩坑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI Chat 网关化重构工作日志：Java AI Gateway 签名上下文与 Python 鉴权落地</title>
    <link href="/2026/02/28/ai-chat-java-ai-gateway-python/"/>
    <url>/2026/02/28/ai-chat-java-ai-gateway-python/</url>
    
    <content type="html"><![CDATA[<p>本篇记录本次 AI Chat 网关化重构的落地结果，重点是把请求入口、认证与业务上下文注入统一收口到 Java 网关，再由 Python 控制平面执行编排。</p><h2 id="改造摘要"><a href="#改造摘要" class="headerlink" title="改造摘要"></a>改造摘要</h2><ol><li>Java 成为 AI Gateway 统一入口：</li></ol><ul><li>前端不再直连 Python，而是走 <code>/api/ai/*</code>。</li><li>Java 在转发到 Python 前注入两类内部头：<ul><li><code>X-AI-GW-TOKEN</code></li><li><code>X-AI-BIZ-CONTEXT</code>（签名业务上下文，包含 <code>userId/tenantDeptId/traceId/iat/exp</code> 等）</li></ul></li></ul><ol start="2"><li>Python 新增并强制执行网关鉴权中间件：</li></ol><ul><li>所有 <code>/ai/*</code> 业务接口默认需要 <code>X-AI-GW-TOKEN + X-AI-BIZ-CONTEXT</code>。</li><li>通过 HMAC 校验上下文签名，并校验时间窗口（<code>iat/exp</code> + <code>AI_GATEWAY_CLOCK_SKEW_SECONDS</code>）。</li><li>鉴权通过后将上下文写入 <code>request.state.auth_context</code>，用于 run owner 与工具上下文注入。</li></ul><ol start="3"><li>前端调用路径统一为 Java 网关：</li></ol><ul><li><code>assistant.js</code> 默认 <code>aiApiPrefix</code> 为 <code>/api/ai</code>。</li><li>前端不再管理 <code>x-user-id/x-tenant-dept-id</code> 直传头，用户上下文由 Java 登录态和网关注入机制统一处理。</li></ul><h2 id="端到端链路（当前状态）"><a href="#端到端链路（当前状态）" class="headerlink" title="端到端链路（当前状态）"></a>端到端链路（当前状态）</h2><pre><code class=" mermaid">flowchart LR  FE[assistant.html / assistant.js] --&gt;|/api/ai/* + Bearer| JGW[Java AI Gateway]  JGW --&gt;|X-AI-GW-TOKEN + X-AI-BIZ-CONTEXT| PY[Python Control Plane]  PY --&gt; MCP[Java MCP tools/list tools/call]  PY --&gt; LLM[Qwen]  PY --&gt; SSE[SSE Events]</code></pre><p>状态结论：</p><ul><li>主链路已打通：前端 -&gt; Java 网关 -&gt; Python -&gt; MCP&#x2F;LLM -&gt; SSE 回流。</li><li>Python 侧已从“可选透传头”切到“默认强制网关签名头”。</li></ul><h2 id="联调排障发现（重点）"><a href="#联调排障发现（重点）" class="headerlink" title="联调排障发现（重点）"></a>联调排障发现（重点）</h2><ol><li><p>无签名头直连 Python 会被拒绝<br>现象：<code>401</code>，提示缺少 <code>X-AI-GW-TOKEN</code> 和 <code>X-AI-BIZ-CONTEXT</code>。<br>结论：符合预期，防止前端或外部直接绕过网关调用。</p></li><li><p>签名或 token 不一致会 401<br>现象：<code>invalid gateway internal token</code> 或 <code>invalid gateway context signature</code>。<br>结论：Java&#x2F;Python 需严格对齐 <code>AI_GATEWAY_INTERNAL_TOKEN</code> 与签名密钥。</p></li><li><p>Biz Context 时间窗口导致偶发失败<br>现象：<code>gateway context expired</code> 或 <code>gateway context iat is in the future</code>。<br>结论：网关与 Python 服务器时间需同步（NTP），并合理设置 <code>AI_GATEWAY_CLOCK_SKEW_SECONDS</code>。</p></li><li><p>前端历史环境仍可能误指向 <code>/ai</code><br>现象：浏览器控制台出现 401&#x2F;跨域或无登录态问题。<br>结论：前端配置必须统一到 <code>/api/ai</code>，由 Java 承担认证与上下文注入。</p></li></ol><h2 id="验证命令（可复现）"><a href="#验证命令（可复现）" class="headerlink" title="验证命令（可复现）"></a>验证命令（可复现）</h2><h3 id="1-Python-单测"><a href="#1-Python-单测" class="headerlink" title="1) Python 单测"></a>1) Python 单测</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/Desktop/Work/ats_iot_ai<br>pytest -q tests/test_runs.py tests/test_sqlite_store.py tests/test_assistant_page.py<br></code></pre></td></tr></table></figure><h3 id="2-网关链路验证（通过-Java）"><a href="#2-网关链路验证（通过-Java）" class="headerlink" title="2) 网关链路验证（通过 Java）"></a>2) 网关链路验证（通过 Java）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -sS -X POST <span class="hljs-string">&#x27;http://127.0.0.1:10001/api/ai/runs&#x27;</span> \<br>  -H <span class="hljs-string">&#x27;Content-Type: application/json&#x27;</span> \<br>  -H <span class="hljs-string">&#x27;Authorization: Bearer &lt;java-login-token&gt;&#x27;</span> \<br>  -H <span class="hljs-string">&#x27;Idempotency-Key: gw-run-001&#x27;</span> \<br>  -d <span class="hljs-string">&#x27;&#123;&quot;query&quot;:&quot;hello&quot;&#125;&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -N <span class="hljs-string">&#x27;http://127.0.0.1:10001/api/ai/runs/&lt;run_id&gt;/events&#x27;</span> \<br>  -H <span class="hljs-string">&#x27;Authorization: Bearer &lt;java-login-token&gt;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="3-负向校验（直连-Python，预期-401）"><a href="#3-负向校验（直连-Python，预期-401）" class="headerlink" title="3) 负向校验（直连 Python，预期 401）"></a>3) 负向校验（直连 Python，预期 401）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -sS -X POST <span class="hljs-string">&#x27;http://127.0.0.1:8000/ai/runs&#x27;</span> \<br>  -H <span class="hljs-string">&#x27;Content-Type: application/json&#x27;</span> \<br>  -d <span class="hljs-string">&#x27;&#123;&quot;query&quot;:&quot;should fail without gateway headers&quot;&#125;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="已知-caveats"><a href="#已知-caveats" class="headerlink" title="已知 caveats"></a>已知 caveats</h2><ul><li><code>AI_ALLOW_LEGACY_AUTH</code> 仅建议迁移期临时开启，长期应关闭，避免回退到明文 legacy 头。</li><li>若 Java 代理层未透传 <code>Last-Event-ID</code>，SSE 断线续传能力会受限。</li><li>网关签名上下文需统一编码与签名算法（当前为 <code>v1.&lt;payload_b64url&gt;.&lt;sig_b64url&gt;</code> 约定），任一端改动都必须同步联调。</li><li>调试时优先查看 Python 返回的 401 明细文案，可快速判断是 token、签名、格式还是时钟问题。</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这次重构把 AI Chat 的“入口、鉴权、上下文注入”彻底收口到 Java 网关，Python 专注编排与执行，前端专注交互。架构边界更清晰，线上排障路径也更短。</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI网关</tag>
      
      <tag>Java</tag>
      
      <tag>Python</tag>
      
      <tag>FastAPI</tag>
      
      <tag>鉴权</tag>
      
      <tag>联调复盘</tag>
      
      <tag>SSE</tag>
      
      <tag>AI工作日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于 OpenClaw 对照改造 iot-framework AI Orchestrator：终结非工具问题 CLARIFY 循环</title>
    <link href="/2026/02/28/openclaw-iot-framework-ai-orchestrator-clarify/"/>
    <url>/2026/02/28/openclaw-iot-framework-ai-orchestrator-clarify/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>这次改造聚焦一个真实线上体验问题：用户问的是通用解释类问题（本质不需要工具），Orchestrator 仍然进入 ReAct 规划，随后触发 <code>CLARIFY</code>，并在后续交互里反复追问，形成“看起来一直要补信息”的循环感。</p><p>目标很明确：在不扩大系统复杂度的前提下，借鉴 OpenClaw 的分层思路，把“是否需要工具”尽早判定，把 <code>CLARIFY</code> 收紧到真正可执行的场景，让非工具问题直接回到 CHAT。</p><h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><p>复现输入（典型）：</p><ul><li>Query：<code>铸造行业的通用定义是什么</code></li><li>可用工具：<code>today_furnace_batches</code> 等业务数据查询工具</li></ul><p>改造前表现（问题态）：</p><ol><li>Query 直接进入 ReAct planner。</li><li>Planner 可能输出 <code>action=CLARIFY</code>，但 <code>tool_name</code> 为空、<code>missing_slots</code> 为空，问题并非“缺参数的工具调用”。</li><li>用户继续回答后，系统仍可能在“澄清-再澄清”路径内打转，无法尽快回到直接回答。</li></ol><p>根因不是模型“笨”，而是编排器缺少足够强的前置闸门与动作约束。</p><h2 id="OpenClaw-关键机制对照"><a href="#OpenClaw-关键机制对照" class="headerlink" title="OpenClaw 关键机制对照"></a>OpenClaw 关键机制对照</h2><p>OpenClaw 给了三个值得借鉴的点：</p><ol><li>先路由再执行：先决定是否走工具链路，再进入工具循环，而不是所有请求都先进入循环。</li><li>结构化动作与守卫：工具调用、终止、澄清都有清晰边界，避免“语义上不成立但语法上合法”的动作继续扩散。</li><li>循环治理：强调无进展循环检测与回退策略，避免 agent 在低价值轨道上反复执行。</li></ol><p>对照下来，我们原链路缺的正是“前置分流 + CLARIFY 可执行性约束 + 明确回退”。</p><h2 id="现状评审"><a href="#现状评审" class="headerlink" title="现状评审"></a>现状评审</h2><p>旧链路的关键风险点：</p><ol><li>没有 <code>CHAT|TOOL|UNKNOWN</code> 前置判定，非工具问题也被送进 ReAct。</li><li><code>CLARIFY</code> 触发条件过宽，只要模型给出 <code>CLARIFY</code> 就可能被接收。</li><li>对“不可执行澄清”缺乏强制回退，导致对用户感知是“问来问去不落地”。</li></ol><p>这三个点叠加后，正好解释了“非工具问题陷入 CLARIFY 循环”。</p><h2 id="奥卡姆方案"><a href="#奥卡姆方案" class="headerlink" title="奥卡姆方案"></a>奥卡姆方案</h2><p>遵循奥卡姆剃刀，这次没有引入新策略层、没有增加多模型协同，只做最小闭环：</p><ol><li>在 ReAct 前增加一个轻量 mode 决策：<code>CHAT|TOOL|UNKNOWN</code>。</li><li>让 <code>CLARIFY</code> 只有在“已锁定具体工具且确实缺必填参数”时才成立。</li><li>对不满足可执行条件的 <code>CLARIFY</code>，直接回退到 CHAT 直答，不继续澄清链路。</li><li>用测试把上述行为固化，避免回归。</li></ol><p>这套方案改动集中、语义清晰、维护成本低。</p><h2 id="改造点（核心）"><a href="#改造点（核心）" class="headerlink" title="改造点（核心）"></a>改造点（核心）</h2><p>这次改造的核心可归纳为四条：</p><ol><li><p><code>CHAT|TOOL|UNKNOWN</code> 前置分流<br>在 <code>_process_input</code> 初始阶段引入 <code>_determine_mode(...)</code>。若判定为 <code>CHAT</code>，直接 <code>policy_decision=chat/respond</code> 并结束；只有 <code>TOOL/UNKNOWN</code> 才进入 ReAct 主循环。</p></li><li><p><code>CLARIFY</code> 触发条件收紧<br>Planner prompt 增加硬规则：非工具问题输出 <code>RESPOND</code>，且只有“已确定 <code>tool_name</code> + 缺必填参数”才能 <code>CLARIFY</code>。<br>同时 <code>_plan_from_intent_route(...)</code> 也改为：只有存在 <code>normalized_call</code> 且有 <code>missing_slots</code> 才映射为 <code>CLARIFY</code>。</p></li><li><p>非可执行 <code>CLARIFY</code> 回退到 CHAT<br>新增 <code>_is_actionable_clarify(...)</code>：若没有具体工具、没有缺失必填参数，判定为不可执行澄清。<br>一旦命中，记录 <code>react_feedback=clarify_without_actionable_tool</code>，再发 <code>policy_decision=chat/fallback</code>，最终走 <code>_direct_answer(query)</code> 结束。</p></li><li><p>相关测试补齐<br>新增并通过关键测试，覆盖“聊天短路”“不可执行澄清回退”与“工具场景仍可多步执行”。</p></li></ol><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>本次改造后在 <code>ats_iot_ai</code> 仓库执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">pytest -q tests/test_runs.py<br><span class="hljs-comment"># 15 passed in 0.28s</span><br><br>pytest -q tests/test_qwen_client.py<br><span class="hljs-comment"># 6 passed in 0.46s</span><br><br>pytest -q<br><span class="hljs-comment"># 37 passed in 0.97s</span><br></code></pre></td></tr></table></figure><p>重点行为用例：</p><ol><li><p><code>test_chat_query_short_circuits_without_react_tool_loop</code><br>验证 CHAT 问题不再进入 <code>react_plan/tool_call/clarification_needed</code>。</p></li><li><p><code>test_non_actionable_clarify_falls_back_to_chat_response</code><br>验证非可执行 <code>CLARIFY</code> 不再继续追问，而是回退直答。</p></li><li><p><code>test_compare_query_forces_second_tool_call_before_respond</code><br>验证工具型对比问题仍保持多步 <code>CALL_TOOL</code> 能力，没有被“过度收紧”误伤。</p></li></ol><h2 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h2><ol><li><code>CLARIFY</code> 不是“兜底动作”，而是“可执行动作”：必须绑定具体工具和缺失参数。</li><li>agent 的第一道关卡应是“是否需要工具”，而不是“先规划再看情况”。</li><li>回退策略要显式可观测（事件化），否则线上很难定位“为什么看起来在打转”。</li><li>简化优先于堆叠：先把错误路径切断，再考虑更复杂的智能优化。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>OpenClaw Docs（Tools &amp; loop detection）：<a href="https://docs.openclaw.ai/architecture/tools">https://docs.openclaw.ai/architecture/tools</a></li><li>OpenClaw Docs（Core architecture）：<a href="https://docs.openclaw.ai/architecture/overview">https://docs.openclaw.ai/architecture/overview</a></li><li>OpenClaw Docs（System prompt &#x2F; tool use policy）：<a href="https://docs.openclaw.ai/architecture/system-prompt">https://docs.openclaw.ai/architecture/system-prompt</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FastAPI</tag>
      
      <tag>AI工作日志</tag>
      
      <tag>ReAct</tag>
      
      <tag>Orchestrator</tag>
      
      <tag>OpenClaw</tag>
      
      <tag>CLARIFY</tag>
      
      <tag>奥卡姆剃刀</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>奥卡姆剃刀式瘦身重构：ats_iot_ai AI 控制面分类复盘</title>
    <link href="/2026/02/27/ats_iot_ai-ai/"/>
    <url>/2026/02/27/ats_iot_ai-ai/</url>
    
    <content type="html"><![CDATA[<p>这次复盘记录的是 <code>ats_iot_ai</code> 一轮典型的「奥卡姆剃刀式瘦身重构」：不再追求架构层面的概念完整性，而是优先保证主流程简单、稳定、可持续迭代。</p><h2 id="背景：项目开始失控，必须回到核心-flow"><a href="#背景：项目开始失控，必须回到核心-flow" class="headerlink" title="背景：项目开始失控，必须回到核心 flow"></a>背景：项目开始失控，必须回到核心 flow</h2><p>随着功能和抽象层不断叠加，编排链路已经从“可理解”滑向“难维护”：策略层、评估层、策略守卫与验证层交织，导致新增一个行为就要跨多个抽象点改动。<br>这轮重构的目标很明确：聚焦核心 flow，把系统重新收敛到一条可解释、可测试、可快速迭代的主路径。</p><h2 id="本次里程碑"><a href="#本次里程碑" class="headerlink" title="本次里程碑"></a>本次里程碑</h2><ol><li><code>Orchestrator</code> 收敛为单一 ReAct 核心循环。</li><li>移除 <code>strategy/eval/policy/guard/verify</code> 这套多层抽象。</li><li>删除对应的复杂测试，保留核心行为测试：<code>run / sse / tool / clarification</code>。</li><li>全量测试结果回归稳定：<code>33 passed</code>。</li></ol><h2 id="关键-Commit"><a href="#关键-Commit" class="headerlink" title="关键 Commit"></a>关键 Commit</h2><ul><li><code>463fc90</code></li><li><code>refactor(orchestrator): collapse to single react loop and remove strategy stack</code></li></ul><p>这次提交基本定义了新架构边界：优先“跑通且可维护”的主链路，而不是保留历史包袱的概念分层。</p><h2 id="重点收益"><a href="#重点收益" class="headerlink" title="重点收益"></a>重点收益</h2><ol><li>复杂度显著下降：调用链更短，排障路径更直接。</li><li>迭代速度提升：新增&#x2F;调整行为时，改动面更小，回归成本更低。</li><li>可维护性改善：核心职责集中，测试更聚焦真实用户路径。</li></ol><h2 id="剩余工作"><a href="#剩余工作" class="headerlink" title="剩余工作"></a>剩余工作</h2><p>下一步计划是把 <code>intent_router</code> 与 <code>clarification slot</code> 进一步并入经典 ReAct 的 <code>plan</code> 步，让意图判定与澄清收集更统一地在单循环内完成，继续减少分叉逻辑和隐式状态。</p><hr><p>这次重构再次验证了一个实践原则：当系统复杂度开始压制交付速度时，最有效的优化通常不是“再加一层”，而是先做减法，回到主流程。</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI工作日志</tag>
      
      <tag>ReAct</tag>
      
      <tag>重构复盘</tag>
      
      <tag>架构简化</tag>
      
      <tag>ats_iot_ai</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PyCharm 调试 Uvicorn/FastAPI 与日志可见性排查</title>
    <link href="/2026/02/27/pycharm-uvicorn-fastapi/"/>
    <url>/2026/02/27/pycharm-uvicorn-fastapi/</url>
    
    <content type="html"><![CDATA[<p>最近在调试一个 FastAPI + Uvicorn 的项目时，遇到两个高频问题：</p><ol><li>PyCharm 里到底怎么正确配 <code>uvicorn main:app</code>？</li><li>代码里明明写了 <code>LOGGER.info(...)</code>，控制台却看不到日志？</li></ol><p>这篇只讲可直接落地的做法。</p><h2 id="1-PyCharm-里如何用-Uvicorn-调试"><a href="#1-PyCharm-里如何用-Uvicorn-调试" class="headerlink" title="1) PyCharm 里如何用 Uvicorn 调试"></a>1) PyCharm 里如何用 Uvicorn 调试</h2><p>新增一个 <code>Python</code> 类型 Run Configuration：</p><ul><li><code>Run</code>: <code>Module name</code></li><li><code>Module name</code>: <code>uvicorn</code></li><li><code>Parameters</code>: <code>main:app --host 127.0.0.1 --port 8000</code></li><li><code>Working directory</code>: 项目根目录</li><li><code>Python interpreter</code>: 安装过依赖的虚拟环境</li></ul><p>建议调试时先不要加 <code>--reload</code>，热重载会拉起子进程，断点命中和日志输出都容易漂。</p><h2 id="2-为什么业务日志看不到"><a href="#2-为什么业务日志看不到" class="headerlink" title="2) 为什么业务日志看不到"></a>2) 为什么业务日志看不到</h2><p>典型现象：</p><ul><li>Uvicorn 启动日志有</li><li>业务代码里的 <code>LOGGER.info(...)</code> 没有</li><li><code>warning/error</code> 偶尔有</li></ul><p>根因通常是：Uvicorn 默认主要配置了 <code>uvicorn.*</code> logger，业务 logger（如 <code>app.*</code>）会冒泡到 root，而 root 默认阈值常是 <code>WARNING</code>，因此 <code>INFO</code> 被过滤。</p><h2 id="3-直接可用的修复方案"><a href="#3-直接可用的修复方案" class="headerlink" title="3) 直接可用的修复方案"></a>3) 直接可用的修复方案</h2><p>在启动入口（例如 <code>main.py</code>）里做一次应用日志初始化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">configure_app_logging</span>() -&gt; <span class="hljs-literal">None</span>:<br>    log_level_name = os.getenv(<span class="hljs-string">&quot;APP_LOG_LEVEL&quot;</span>, <span class="hljs-string">&quot;INFO&quot;</span>).upper()<br>    log_level = <span class="hljs-built_in">getattr</span>(logging, log_level_name, logging.INFO)<br><br>    root_logger = logging.getLogger()<br>    root_logger.setLevel(log_level)<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root_logger.handlers:<br>        handler = logging.StreamHandler()<br>        handler.setFormatter(<br>            logging.Formatter(<span class="hljs-string">&quot;%(asctime)s %(levelname)s [%(name)s] %(message)s&quot;</span>)<br>        )<br>        root_logger.addHandler(handler)<br><br>    logging.getLogger(<span class="hljs-string">&quot;app&quot;</span>).setLevel(log_level)<br></code></pre></td></tr></table></figure><p>需要更详细日志时：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">APP_LOG_LEVEL=DEBUG<br></code></pre></td></tr></table></figure><h2 id="4-最小验证方法"><a href="#4-最小验证方法" class="headerlink" title="4) 最小验证方法"></a>4) 最小验证方法</h2><ol><li>启动后打一个断点。</li><li>在断点附近写：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">LOGGER.info(<span class="hljs-string">&quot;debug_probe run_id=%s&quot;</span>, run_id)<br></code></pre></td></tr></table></figure><ol start="3"><li>看 PyCharm Debug Console 是否出现：</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">2026-xx-xx xx:xx:xx,xxx INFO [app.orchestrator] debug_probe run_id=...<br></code></pre></td></tr></table></figure><p>出现就说明链路打通了。</p><h2 id="5-三个容易踩坑的点"><a href="#5-三个容易踩坑的点" class="headerlink" title="5) 三个容易踩坑的点"></a>5) 三个容易踩坑的点</h2><ol><li>直接 Run <code>main.py</code> 期待服务自动启动（多数项目不会，除非你写了 <code>if __name__ == &quot;__main__&quot;</code> 启动逻辑）。</li><li>项目里有多个 venv，PyCharm 解释器选错。</li><li>调试期默认开 <code>--reload</code>，导致你以为“断点或日志失效”。</li></ol><p>如果你在做 FastAPI 的日常开发，这套配置建议固化成团队模板，能省掉不少无效排查时间。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>FastAPI</tag>
      
      <tag>Uvicorn</tag>
      
      <tag>PyCharm</tag>
      
      <tag>调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI Chat 重构总复盘：Java MCP 收口、LLM 路由与稳定性治理</title>
    <link href="/2026/02/27/ai-chat-refactor-llm-intent-timeout-hardening-20260227/"/>
    <url>/2026/02/27/ai-chat-refactor-llm-intent-timeout-hardening-20260227/</url>
    
    <content type="html"><![CDATA[<h2 id="目标与边界"><a href="#目标与边界" class="headerlink" title="目标与边界"></a>目标与边界</h2><p>本轮重构的目标是把 AI 聊天从“Java 单体链路”收敛为“Python 控制平面 + Java MCP 执行平面”，并解决线上已暴露的问题：</p><ul><li>普通聊天误入 ReAct</li><li>MCP 工具失败导致 run 直接失败</li><li>Qwen 超时后返回 <code>echo</code></li><li>联调时 Python&#x2F;Java token 不一致导致 MCP 401</li></ul><p>边界上，Java 只保留 MCP + Tool 能力；会话编排、SSE、策略、前端调试全部归到 Python。</p><h2 id="最终架构"><a href="#最终架构" class="headerlink" title="最终架构"></a>最终架构</h2><pre><code class=" mermaid">flowchart LR  FE[AI Assistant / Debug UI] --&gt; PY[Python ai-gateway + orchestrator]  PY --&gt;|tools/list tools/call| JM[Java MCP Server]  JM --&gt; TOOLS[业务 Tool 实现]  PY --&gt; QWEN[Qwen API]  PY --&gt; STORE[RunStore + Events]</code></pre><h2 id="本次整体改动（按模块）"><a href="#本次整体改动（按模块）" class="headerlink" title="本次整体改动（按模块）"></a>本次整体改动（按模块）</h2><h3 id="1-Java-侧：AI-模块收口为-MCP-only"><a href="#1-Java-侧：AI-模块收口为-MCP-only" class="headerlink" title="1) Java 侧：AI 模块收口为 MCP-only"></a>1) Java 侧：AI 模块收口为 MCP-only</h3><ul><li>移除非 MCP 的旧 AI 运行链路、历史配置和无关依赖，降低维护面。</li><li>工具注册与元数据从 LangChain4j 解耦，保留必要实体与执行能力。</li><li>新增&#x2F;增强 MCP 入口能力：<code>tools/list</code>、<code>tools/call</code>、上下文解析与注入快照。</li><li>完成 MCP 端单测替换：从旧测试迁移到 MCP 端点覆盖。</li><li>增加本地&#x2F;开发调试必需能力（如 dev&#x2F;local 启动兼容、调试登录入口）。</li></ul><h3 id="2-Python-侧：编排能力生产化"><a href="#2-Python-侧：编排能力生产化" class="headerlink" title="2) Python 侧：编排能力生产化"></a>2) Python 侧：编排能力生产化</h3><ul><li>意图路由改为 LLM-first，统一 <code>IntentRouter -&gt; Policy -&gt; Strategy</code>。</li><li>策略明确化：<ul><li><code>CHAT -&gt; DIRECT</code></li><li><code>TOOL_CALL/ANALYZE/TRACE -&gt; REACT</code></li></ul></li><li>ReAct 失败时不再硬失败，触发 <code>tool_fallback</code> 后降级 DIRECT，保证会话可恢复。</li><li>运行时绑定与上下文快照注入，增强跨事件可追踪性。</li></ul><h3 id="3-MCP-联调治理"><a href="#3-MCP-联调治理" class="headerlink" title="3) MCP 联调治理"></a>3) MCP 联调治理</h3><ul><li>Python MCP token 来源简化为 <code>MCP_API_TOKEN</code>，本地默认 <code>AAA</code>。</li><li>与 Java MCP internal token 对齐，修复 401 鉴权不一致问题。</li><li>启动日志和调试页展示 Java MCP 连接状态，联调可视化更直接。</li></ul><h3 id="4-Qwen-稳定性治理"><a href="#4-Qwen-稳定性治理" class="headerlink" title="4) Qwen 稳定性治理"></a>4) Qwen 稳定性治理</h3><ul><li>去掉异常时 <code>echo: 用户问题</code> 的回退行为。</li><li>超时与重试参数化：<ul><li><code>QWEN_TIMEOUT_SECONDS=60</code></li><li><code>QWEN_MAX_RETRIES=2</code></li></ul></li><li>失败时统一用户可读文案：<code>当前模型服务暂不可用，请稍后重试。</code></li></ul><h3 id="5-前端与开发体验"><a href="#5-前端与开发体验" class="headerlink" title="5) 前端与开发体验"></a>5) 前端与开发体验</h3><ul><li>调试页升级为左右分栏：<ul><li>左侧紧凑时间轴卡片（摘要）</li><li>右侧原始 SSE 事件（明细）</li></ul></li><li>新增独立用户态页面 <code>assistant.html</code>，与开发调试页分离。</li><li>启动脚本简化并默认跟踪日志，减少“启动了但看不到日志”的调试成本。</li></ul><h2 id="关键问题与修复闭环"><a href="#关键问题与修复闭环" class="headerlink" title="关键问题与修复闭环"></a>关键问题与修复闭环</h2><ol><li><p><code>query=你是谁</code> 误走 ReAct并返回 echo<br>修复：LLM 意图统一路由 + DirectStrategy 取消 echo fallback。</p></li><li><p>MCP 401 (<code>mcp_unauthorized</code>)<br>修复：Python&#x2F;Java token 统一策略，默认 <code>AAA</code>，链路可观测。</p></li><li><p>模型超时导致体验不可控<br>修复：Qwen 超时提升到 60s + 重试 + 明确降级文案。</p></li></ol><h2 id="结果验收"><a href="#结果验收" class="headerlink" title="结果验收"></a>结果验收</h2><ul><li>Python 侧自动化测试通过（本轮关键节点执行过 <code>pytest -q</code>，通过）。</li><li>聊天与工具调用链路从“硬失败”转为“可恢复”。</li><li>Java 侧职责收敛，后续可以围绕 Tool 能力继续扩展，而不再背负编排复杂度。</li></ul><h2 id="仍待收尾"><a href="#仍待收尾" class="headerlink" title="仍待收尾"></a>仍待收尾</h2><ul><li>部分业务工具在特定上下文下仍可能返回 Java 500（例如个别炉次查询场景）。</li><li>下一步重点是工具级根因治理与端到端业务正确性校验（尤其 scope: tenant&#x2F;dept&#x2F;user 注入一致性）。</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这次重构的核心价值不是“功能变多”，而是“系统边界清晰 + 失败可恢复 + 可观测可迭代”：</p><ul><li>Java 专注 MCP Tool 执行平面</li><li>Python 专注编排与交互控制平面</li><li>线上故障从“脆断”变成“降级可用”</li></ul>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FastAPI</tag>
      
      <tag>AI工作日志</tag>
      
      <tag>MCP</tag>
      
      <tag>Qwen</tag>
      
      <tag>ReAct</tag>
      
      <tag>稳定性</tag>
      
      <tag>重构复盘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI控制面生产化改造：LLM意图路由与ReAct执行边界</title>
    <link href="/2026/02/25/ai-llm-react/"/>
    <url>/2026/02/25/ai-llm-react/</url>
    
    <content type="html"><![CDATA[<p>这次改造把 <code>ats_iot_ai</code> 的 Orchestrator 从 MVP 规则路由，切到生产模式的 LLM 驱动编排。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>线上痛点很明确：<code>process_input</code> 里 <code>IntentRouter.route(query)</code> 主要依赖模式匹配，无法稳定处理语义歧义、槽位缺失和复杂意图。与此同时，React 执行层存在 query 二次解析，执行边界不够清晰。</p><p>目标是把链路拉直为：</p><p><code>Understand -&gt; Decide -&gt; Act -&gt; Verify -&gt; Respond</code></p><h2 id="本次核心变更"><a href="#本次核心变更" class="headerlink" title="本次核心变更"></a>本次核心变更</h2><ol><li><code>IntentRouter</code> 升级为 <strong>LLM-based</strong> 主路径。</li></ol><ul><li>保留 deterministic fast path：<code>tool:&lt;name&gt; &#123;json&#125;</code>。</li><li>其他请求走 Qwen 结构化解析（intent&#x2F;confidence&#x2F;slots&#x2F;missing_slots&#x2F;tool_plan）。</li></ul><ol start="2"><li>新增 <code>QwenIntentParser</code>。</li></ol><ul><li>强约束 JSON 输出。</li><li>解析失败自动回退到安全 chat 路由，避免阻塞主流程。</li></ul><ol start="3"><li><code>PolicyEngine</code> 从静态 strategy map 升级为决策闸门。</li></ol><ul><li>新增 action：<code>execute/clarify/fallback/deny</code>。</li><li>引入 confidence 阈值与 missing_slots 规则。</li></ul><ol start="4"><li><code>ReactStrategy</code> 去掉 query 二次解析。</li></ol><ul><li>仅消费结构化 <code>tool_call</code>，执行输入边界可控。</li></ul><ol start="5"><li>引入 <code>Verify</code> 最小硬规则。</li></ol><ul><li>先落三条：schema、权限上下文、空结果。</li><li>校验失败写出 <code>verification_failed</code> 事件并终止错误收敛。</li></ul><ol start="6"><li>SSE 事件链路增强。</li></ol><ul><li><code>intent_determined</code> 增加 confidence&#x2F;candidates&#x2F;slots&#x2F;missingSlots&#x2F;toolPlan。</li><li><code>policy_decision</code> 增加 action。</li><li>新增 <code>clarification_needed</code>、<code>verification_failed</code>。</li></ul><h2 id="代码落点"><a href="#代码落点" class="headerlink" title="代码落点"></a>代码落点</h2><ul><li><code>app/orchestration/intent_router.py</code></li><li><code>app/orchestration/intent_llm_parser.py</code></li><li><code>app/orchestration/policy_engine.py</code></li><li><code>app/orchestration/strategies.py</code></li><li><code>app/orchestration/verify.py</code></li><li><code>app/orchestrator.py</code></li><li><code>tests/orchestrator/*</code></li></ul><h2 id="文档同步"><a href="#文档同步" class="headerlink" title="文档同步"></a>文档同步</h2><ul><li><code>README.md</code> 切到 Production Mode 描述。</li><li><code>docs/REACT_ORCHESTRATOR_INTENT_UPGRADE_SPEC.md</code> 升级为生产基线（LLM 主路径、Policy 闸门、Verify 必经）。</li><li>对应 skill 文档也从 MVP 调整为 production 导向。</li></ul><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><ul><li>Orchestrator 核心回归通过。</li><li>全量测试通过（本次改造后运行结果：<code>49 passed</code>）。</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这次改造的关键不是“把 ReAct 做复杂”，而是先把生产边界做正确：</p><ul><li>语义理解交给 LLM（结构化输出）</li><li>执行决策交给 Policy（代码闸门）</li><li>执行结果交给 Verify（质量防线）</li></ul><p>下一步会继续做 LLM parser 的生产强化：schema 校验加强、重试与降级策略、prompt&#x2F;version 管理和可观测性细化。</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI工作日志</tag>
      
      <tag>Qwen</tag>
      
      <tag>ReAct</tag>
      
      <tag>Orchestrator</tag>
      
      <tag>IntentRouter</tag>
      
      <tag>PolicyEngine</tag>
      
      <tag>Verify</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ReAct Orchestrator 意图识别升级：踩坑与 QA 纪要</title>
    <link href="/2026/02/25/react-orchestrator-qa/"/>
    <url>/2026/02/25/react-orchestrator-qa/</url>
    
    <content type="html"><![CDATA[<p>这篇记录来自一次真实的架构评审：我们发现当前 Orchestrator 在意图识别阶段还偏“query直通”，导致后续策略选择和工具调用容易偏离用户真实意图。本文沉淀核心踩坑、关键 QA 结论和可执行改造路径。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>当前链路已经可用：<code>/ai/runs</code> + SSE + Tool Call。但意图层的主要问题是：</p><ol><li>路由以规则&#x2F;关键词为主，语义理解和槽位抽取不足。</li><li>Policy 更像静态映射，不是执行闸门。</li><li>React 执行层仍可能从原始 query 反向 parse 工具调用。</li><li>Tool 成功返回后，缺少统一 Verify 防线。</li></ol><h2 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><h3 id="坑1：把“路由命中”当成“意图识别完成”"><a href="#坑1：把“路由命中”当成“意图识别完成”" class="headerlink" title="坑1：把“路由命中”当成“意图识别完成”"></a>坑1：把“路由命中”当成“意图识别完成”</h3><p><code>tool:xxx &#123;json&#125;</code> 命中只能说明格式命中，不代表用户任务真正可执行。现实里经常出现：</p><ul><li>参数不全（缺设备、时间范围）</li><li>参数不合法（schema 不匹配）</li><li>意图冲突（用户其实想“分析原因”，不是“直接执行某工具”）</li></ul><p>结论：必须输出结构化理解对象，而不是只输出一个策略枚举。</p><h3 id="坑2：把策略选择完全交给模型"><a href="#坑2：把策略选择完全交给模型" class="headerlink" title="坑2：把策略选择完全交给模型"></a>坑2：把策略选择完全交给模型</h3><p>如果没有代码层 Policy Gate，模型就既当“语义理解者”又当“执行裁判”。在工业场景这会带来权限、越权、误执行风险。</p><p>结论：让模型决定“可能是什么”，让代码决定“能不能做”。</p><h3 id="坑3：把-Observation-当-Verify"><a href="#坑3：把-Observation-当-Verify" class="headerlink" title="坑3：把 Observation 当 Verify"></a>坑3：把 Observation 当 Verify</h3><p>拿到工具返回（Observation）不等于结果可用。常见失败：</p><ul><li>返回缺关键字段</li><li>结果与上下文不一致</li><li>数据跨租户越权</li></ul><p>结论：Observation 是事实输入，Verify 是规则判定，必须分开。</p><h3 id="坑4：盲目要求输出完整-CoT"><a href="#坑4：盲目要求输出完整-CoT" class="headerlink" title="坑4：盲目要求输出完整 CoT"></a>坑4：盲目要求输出完整 CoT</h3><p>我们讨论后明确：可让模型进行内部推理，但不建议把原始 CoT 作为产品输出，也不建议把长 CoT 作为编排决策主输入。</p><p>结论：编排层只消费结构化字段 + 简短 rationale。</p><h2 id="QA-讨论结论"><a href="#QA-讨论结论" class="headerlink" title="QA 讨论结论"></a>QA 讨论结论</h2><h3 id="Q1：Understand-和-Decide-能不能合并？"><a href="#Q1：Understand-和-Decide-能不能合并？" class="headerlink" title="Q1：Understand 和 Decide 能不能合并？"></a>Q1：Understand 和 Decide 能不能合并？</h3><p>可以在“一次 LLM 调用”中产出理解和候选动作，但架构职责不建议合并。</p><ul><li>Understand：语义解析与结构化产出（intent、slots、confidence）</li><li>Decide：代码层 Policy 决策（execute&#x2F;clarify&#x2F;fallback&#x2F;deny）</li></ul><h3 id="Q2：Reasoning-输入输出到底是什么？"><a href="#Q2：Reasoning-输入输出到底是什么？" class="headerlink" title="Q2：Reasoning 输入输出到底是什么？"></a>Q2：Reasoning 输入输出到底是什么？</h3><p>推荐输入：</p><ul><li>用户 query</li><li>历史上下文摘要</li><li>工具描述+参数 schema</li><li>当前运行状态（重试次数、预算、前序失败）</li><li>策略约束（权限、风险规则）</li></ul><p>推荐输出（强结构化）：</p><ul><li><code>intent</code></li><li><code>confidence</code></li><li><code>candidates</code></li><li><code>slots</code></li><li><code>missing_slots</code></li><li><code>next_action</code></li><li><code>tool_plan</code></li><li><code>clarification_question</code></li><li><code>brief_rationale</code></li></ul><h3 id="Q3：Verify-是不是-Observation？"><a href="#Q3：Verify-是不是-Observation？" class="headerlink" title="Q3：Verify 是不是 Observation？"></a>Q3：Verify 是不是 Observation？</h3><p>不是。</p><ul><li>Observation：工具执行后的原始返回</li><li>Verify：对返回做完整性&#x2F;一致性&#x2F;权限&#x2F;风险校验</li></ul><p>ReAct 推荐循环：<br><code>Reason -&gt; Act -&gt; Observe -&gt; Verify -&gt; (继续/结束)</code></p><h3 id="Q4：槽位缺失怎么处理？"><a href="#Q4：槽位缺失怎么处理？" class="headerlink" title="Q4：槽位缺失怎么处理？"></a>Q4：槽位缺失怎么处理？</h3><p>缺关键槽位时不执行工具，进入澄清：</p><ul><li>触发 <code>clarification_needed</code></li><li>一次只问 1-2 个关键问题</li><li>用户补充后合并上下文再推理</li><li>超过最大澄清轮次则 fallback 或人工接管</li></ul><h3 id="Q5：Qwen-是否建议输出-CoT？"><a href="#Q5：Qwen-是否建议输出-CoT？" class="headerlink" title="Q5：Qwen 是否建议输出 CoT？"></a>Q5：Qwen 是否建议输出 CoT？</h3><p>结论：可以启用 thinking 用于内部推理&#x2F;调试，但默认不把原始 CoT 回给用户。系统对外以结构化结果和简短解释为主。</p><h2 id="最终落地优先级（先做这4项）"><a href="#最终落地优先级（先做这4项）" class="headerlink" title="最终落地优先级（先做这4项）"></a>最终落地优先级（先做这4项）</h2><ol><li>ReactStrategy 不再从 query 二次 parse tool call，只接受结构化 <code>tool_call</code>。</li><li>PolicyEngine 增加 <code>action</code>（<code>execute/clarify/fallback/deny</code>）与阈值配置。</li><li>新增 <code>clarification_needed</code> 事件，承接缺槽位追问流程。</li><li>增加 Verify 最小闭环（schema + 权限 + 空结果 三条硬规则）。</li></ol><h2 id="建议迭代顺序"><a href="#建议迭代顺序" class="headerlink" title="建议迭代顺序"></a>建议迭代顺序</h2><ul><li>Iter A：先扩结构（不改行为）</li><li>Iter B：Policy 阀门化 + 澄清</li><li>Iter C：React 去 query 直通</li><li>Iter D：Verify 校验器</li></ul><p>这样可以在不打断现有可用链路的前提下，逐步逼近“可解释、可治理、可回滚”的 ReAct 编排架构。</p><h2 id="复盘一句话"><a href="#复盘一句话" class="headerlink" title="复盘一句话"></a>复盘一句话</h2><p>MVP 能跑是起点，生产级 ReAct 的关键不是“让模型多想”，而是把“理解、决策、执行、校验”边界拉直，并让代码掌握最终执行权。</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI工作日志</tag>
      
      <tag>ReAct</tag>
      
      <tag>Orchestrator</tag>
      
      <tag>AI工程</tag>
      
      <tag>意图识别</tag>
      
      <tag>Tool Calling</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java/Python MCP 401 排查里程碑：Token 对齐与方案简化</title>
    <link href="/2026/02/21/java-python-mcp-401-token/"/>
    <url>/2026/02/21/java-python-mcp-401-token/</url>
    
    <content type="html"><![CDATA[<p>本篇记录本次 Java&#x2F;Python MCP 401 问题的收敛结论、方案调整与发布证据。</p><h2 id="里程碑结论"><a href="#里程碑结论" class="headerlink" title="里程碑结论"></a>里程碑结论</h2><ul><li>401 根因已确认：Java 侧与 Python 侧在 MCP 鉴权 token 上不一致，导致请求头 <code>X-AI-MCP-TOKEN</code> 校验失败。</li><li>方案已简化：Python 侧仅保留一个配置入口 <code>MCP_API_TOKEN</code>，默认值固定为 <code>AAA</code>，移除复杂 fallback 链路，减少歧义与隐式行为。</li></ul><h2 id="方案变更说明（单一目的）"><a href="#方案变更说明（单一目的）" class="headerlink" title="方案变更说明（单一目的）"></a>方案变更说明（单一目的）</h2><p>本次变更目标只有一个：让 Python MCPClient 的 token 来源明确、默认行为稳定，避免再次出现“配置看似生效但实际不一致”的 401。</p><ul><li>配置入口：<code>MCP_API_TOKEN</code></li><li>默认值：<code>AAA</code></li><li>行为：若未显式设置环境变量，统一走默认 <code>AAA</code>；若设置了 <code>MCP_API_TOKEN</code>，严格使用该值。</li></ul><h2 id="验证证据"><a href="#验证证据" class="headerlink" title="验证证据"></a>验证证据</h2><h3 id="1-直连-probe（MCP-可达性-工具数量）"><a href="#1-直连-probe（MCP-可达性-工具数量）" class="headerlink" title="1) 直连 probe（MCP 可达性 + 工具数量）"></a>1) 直连 probe（MCP 可达性 + 工具数量）</h3><p>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -sS -X POST <span class="hljs-string">&#x27;http://127.0.0.1:10001/ai/mcp/tools/list&#x27;</span> \<br>  -H <span class="hljs-string">&#x27;Content-Type: application/json&#x27;</span> \<br>  -H <span class="hljs-string">&#x27;X-AI-MCP-TOKEN: AAA&#x27;</span> \<br>  -d <span class="hljs-string">&#x27;&#123;&#125;&#x27;</span><br><br>curl -sS <span class="hljs-string">&#x27;http://127.0.0.1:8000/system/mcp/status?refresh=true&#x27;</span><br></code></pre></td></tr></table></figure><p>结果要点：</p><ul><li><code>tools/list</code> 返回 <code>code=200</code></li><li><code>system/mcp/status</code> 返回：<ul><li><code>connected=true</code></li><li><code>tool_count=10</code></li><li><code>detail=&quot;ok (tools=10)&quot;</code></li></ul></li></ul><h3 id="2-Python-单测"><a href="#2-Python-单测" class="headerlink" title="2) Python 单测"></a>2) Python 单测</h3><p>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pytest tests/test_mcp_client.py<br></code></pre></td></tr></table></figure><p>结果要点：</p><ul><li><code>collected 5 items</code></li><li><code>5 passed</code></li><li>核验覆盖了：<ul><li>未设置 <code>MCP_API_TOKEN</code> 时默认 <code>AAA</code></li><li>设置 <code>MCP_API_TOKEN</code> 时优先使用环境变量值</li></ul></li></ul><h2 id="回滚与风险说明（按-SPEC）"><a href="#回滚与风险说明（按-SPEC）" class="headerlink" title="回滚与风险说明（按 SPEC）"></a>回滚与风险说明（按 SPEC）</h2><h3 id="可追溯"><a href="#可追溯" class="headerlink" title="可追溯"></a>可追溯</h3><ul><li>结论、命令、结果均已固化在本工作日志。</li><li>验证入口固定：<code>/system/mcp/status?refresh=true</code> 与 <code>tests/test_mcp_client.py</code>。</li></ul><h3 id="可回退"><a href="#可回退" class="headerlink" title="可回退"></a>可回退</h3><p>若线上出现不兼容，可按最小改动回退：</p><ol><li>回退 Python 侧本次 token 简化提交（仅回退 token 配置相关变更）。</li><li>恢复旧配置逻辑后，立即执行：<ul><li><code>pytest tests/test_mcp_client.py</code></li><li><code>curl .../system/mcp/status?refresh=true</code></li></ul></li><li>以 <code>connected</code>、<code>tool_count</code>、401 告警是否消失作为回退验收。</li></ol><h3 id="单一目的变更"><a href="#单一目的变更" class="headerlink" title="单一目的变更"></a>单一目的变更</h3><ul><li>本次只处理 MCP token 对齐与默认值策略，不扩展到工具路由、SSE、RunStore 等其他模块。</li><li>遵循最小变更面，降低联动回归风险。</li></ul><h2 id="后续观察项"><a href="#后续观察项" class="headerlink" title="后续观察项"></a>后续观察项</h2><ul><li>统一各环境（dev&#x2F;test&#x2F;prod）<code>MCP_API_TOKEN</code> 注入方式，避免“本地默认可用、环境变量缺失”导致偏差。</li><li>监控 Java MCP 401&#x2F;403 比例，作为 token 配置漂移的早期信号。</li></ul>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Python</tag>
      
      <tag>AI工作日志</tag>
      
      <tag>MCP</tag>
      
      <tag>里程碑</tag>
      
      <tag>401排查</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RAG可插拔改造复盘：OpenSearch混合检索、RRF与增量Ingest</title>
    <link href="/2026/02/21/rag-opensearch-rrf-ingest/"/>
    <url>/2026/02/21/rag-opensearch-rrf-ingest/</url>
    
    <content type="html"><![CDATA[<h2 id="一句话结论"><a href="#一句话结论" class="headerlink" title="一句话结论"></a>一句话结论</h2><p>这轮我把 RAG 从“单一本地检索”改造成“可插拔检索链路”：新增 OpenSearch Provider（BM25+向量+过滤）、Hybrid RRF、低置信&#x2F;复杂 Query 的 rerank 触发、分钟级增量 ingest + upsert，并通过 fallback + 默认开关关闭确保 <code>/ai/runs</code> 主链路稳定不受影响。</p><h2 id="Done-标准"><a href="#Done-标准" class="headerlink" title="Done 标准"></a>Done 标准</h2><ul><li><input checked="" disabled="" type="checkbox"> 检索 Provider 可插拔：本地内存与 OpenSearch 可切换。</li><li><input checked="" disabled="" type="checkbox"> OpenSearch 支持 BM25 + 向量召回 + 租户&#x2F;可见性过滤。</li><li><input checked="" disabled="" type="checkbox"> 支持 Hybrid RRF 融合，且可开关。</li><li><input checked="" disabled="" type="checkbox"> 低置信或复杂 Query 才触发 rerank，避免全量增延迟。</li><li><input checked="" disabled="" type="checkbox"> ingest 支持分钟级调度、增量检测、文档删除同步与 upsert。</li><li><input checked="" disabled="" type="checkbox"> OpenSearch 异常时自动 fallback 到本地检索。</li><li><input checked="" disabled="" type="checkbox"> 默认开关关闭，且 <code>/ai/runs</code> 主链路回归通过。</li></ul><h2 id="Situation（背景）"><a href="#Situation（背景）" class="headerlink" title="Situation（背景）"></a>Situation（背景）</h2><p>现状是 AI Control Plane 已有稳定的 <code>/ai/runs</code> 异步链路，同时 RAG 只有本地内存检索能力。业务目标是把检索能力升级为可插拔且可渐进上线，但不能把风险引入主链路。</p><p>证据锚点：</p><ul><li>主链路仍以 <code>/ai/runs</code> 为核心接口：<code>/Users/willfordzhan/Desktop/Work/ats_iot_ai-rag-service/README.md:4</code></li><li>RAG 与主链路并存：<code>/Users/willfordzhan/Desktop/Work/ats_iot_ai-rag-service/README.md:13</code></li><li>应用入口中 <code>/ai/runs</code> 保持既有定义：<code>/Users/willfordzhan/Desktop/Work/ats_iot_ai-rag-service/app/api.py:98</code></li></ul><h2 id="Task（任务）"><a href="#Task（任务）" class="headerlink" title="Task（任务）"></a>Task（任务）</h2><p>在不破坏现有 <code>/ai/runs</code> 行为的前提下，完成 RAG 可插拔改造，覆盖以下能力：</p><ol><li>OpenSearch Provider：BM25 + 向量 + 过滤。</li><li>Hybrid RRF 融合策略。</li><li>低置信&#x2F;复杂 Query rerank 触发机制。</li><li>分钟级增量 ingest + upsert。</li><li>fallback 到本地检索，默认开关关闭。</li></ol><p>证据锚点：</p><ul><li>开关默认关闭：<code>/Users/willfordzhan/Desktop/Work/ats_iot_ai-rag-service/app/rag/config.py:17</code></li><li>统一读取环境变量开关：<code>/Users/willfordzhan/Desktop/Work/ats_iot_ai-rag-service/app/rag/config.py:66</code></li></ul><h2 id="Action（行动）"><a href="#Action（行动）" class="headerlink" title="Action（行动）"></a>Action（行动）</h2><h3 id="1-抽象-RetrievalManager，落地-Provider-可插拔"><a href="#1-抽象-RetrievalManager，落地-Provider-可插拔" class="headerlink" title="1) 抽象 RetrievalManager，落地 Provider 可插拔"></a>1) 抽象 RetrievalManager，落地 Provider 可插拔</h3><ul><li>通过 <code>RetrievalManager</code> 注入 <code>local_provider</code> 和 <code>opensearch_provider</code>，把“检索策略编排”与“具体检索实现”解耦。</li><li>默认仍可只用本地检索，避免强依赖 OpenSearch。</li></ul><p>证据锚点：</p><ul><li>管理器依赖注入点：<code>/Users/willfordzhan/Desktop/Work/ats_iot_ai-rag-service/app/rag/retrieval_manager.py:141</code></li><li>OpenSearch provider 延迟初始化（按开关启用）：<code>/Users/willfordzhan/Desktop/Work/ats_iot_ai-rag-service/app/rag/retrieval_manager.py:263</code></li></ul><h3 id="2-新增-OpenSearch-Provider（BM25-向量-过滤）"><a href="#2-新增-OpenSearch-Provider（BM25-向量-过滤）" class="headerlink" title="2) 新增 OpenSearch Provider（BM25 + 向量 + 过滤）"></a>2) 新增 OpenSearch Provider（BM25 + 向量 + 过滤）</h3><ul><li>BM25 使用 <code>multi_match</code>，向量使用 <code>knn</code>，两路都带 <code>tenant_dept_id</code> 与 <code>visibility</code> 过滤，保证多租户隔离语义一致。</li><li>通过 <code>OpenSearchClient</code> 封装 <code>search / bulk upsert / delete_by_query</code>。</li></ul><p>证据锚点：</p><ul><li>BM25 构造：<code>/Users/willfordzhan/Desktop/Work/ats_iot_ai-rag-service/app/rag/opensearch/query_builder.py:20</code></li><li>向量查询与 filter：<code>/Users/willfordzhan/Desktop/Work/ats_iot_ai-rag-service/app/rag/opensearch/query_builder.py:47</code></li><li>Provider 双路召回：<code>/Users/willfordzhan/Desktop/Work/ats_iot_ai-rag-service/app/rag/retrieval_manager.py:96</code></li><li>OpenSearch 客户端能力：<code>/Users/willfordzhan/Desktop/Work/ats_iot_ai-rag-service/app/rag/opensearch/client.py:46</code></li></ul><h3 id="3-加入-Hybrid-RRF（可开关）"><a href="#3-加入-Hybrid-RRF（可开关）" class="headerlink" title="3) 加入 Hybrid RRF（可开关）"></a>3) 加入 Hybrid RRF（可开关）</h3><ul><li>OpenSearch 两路结果先并行召回，再按开关选择：<ul><li>开启：<code>reciprocal_rank_fusion</code></li><li>关闭：<code>combine_by_best_score</code></li></ul></li><li>这样可以在“相关性融合效果”与“实现复杂度”之间保留调优空间。</li></ul><p>证据锚点：</p><ul><li>RRF 实现：<code>/Users/willfordzhan/Desktop/Work/ats_iot_ai-rag-service/app/rag/hybrid_rrf.py:8</code></li><li>Manager 中融合开关：<code>/Users/willfordzhan/Desktop/Work/ats_iot_ai-rag-service/app/rag/retrieval_manager.py:227</code></li></ul><h3 id="4-只在必要时触发-rerank（低置信-复杂-Query）"><a href="#4-只在必要时触发-rerank（低置信-复杂-Query）" class="headerlink" title="4) 只在必要时触发 rerank（低置信&#x2F;复杂 Query）"></a>4) 只在必要时触发 rerank（低置信&#x2F;复杂 Query）</h3><ul><li>触发规则：<ul><li>置信度低（如 <code>low</code>）直接触发；</li><li>或 Query 足够复杂（token&#x2F;长度&#x2F;关键词&#x2F;标点特征）。</li></ul></li><li>目标是避免对所有请求统一加 rerank 延迟。</li></ul><p>证据锚点：</p><ul><li>触发策略定义：<code>/Users/willfordzhan/Desktop/Work/ats_iot_ai-rag-service/app/rag/rerank/trigger.py:33</code></li><li>检索流程中条件触发：<code>/Users/willfordzhan/Desktop/Work/ats_iot_ai-rag-service/app/rag/retrieval_manager.py:186</code></li></ul><h3 id="5-增量-ingest-upsert（分钟级）"><a href="#5-增量-ingest-upsert（分钟级）" class="headerlink" title="5) 增量 ingest + upsert（分钟级）"></a>5) 增量 ingest + upsert（分钟级）</h3><ul><li>用 <code>IngestOffsetTracker</code> 对文档签名做差分，只处理变更&#x2F;删除文档。</li><li><code>RAGIngestScheduler</code> 支持周期触发（默认 60 秒）与手动触发。</li><li>upsert 路径先更新本地索引，再尝试 OpenSearch 同步，失败不阻塞本地可用性。</li></ul><p>证据锚点：</p><ul><li>调度器执行与 delta 计算：<code>/Users/willfordzhan/Desktop/Work/ats_iot_ai-rag-service/app/rag/ingest/scheduler.py:97</code></li><li>偏移签名与提交：<code>/Users/willfordzhan/Desktop/Work/ats_iot_ai-rag-service/app/rag/ingest/offset_tracker.py:22</code></li><li>OpenSearch replace&#x2F;upsert：<code>/Users/willfordzhan/Desktop/Work/ats_iot_ai-rag-service/app/rag/opensearch/ingest_adapter.py:13</code></li><li>分钟级配置默认值：<code>/Users/willfordzhan/Desktop/Work/ats_iot_ai-rag-service/app/rag/config.py:48</code></li></ul><h3 id="6-稳定性保护：fallback、本地优先可用、默认关闭"><a href="#6-稳定性保护：fallback、本地优先可用、默认关闭" class="headerlink" title="6) 稳定性保护：fallback、本地优先可用、默认关闭"></a>6) 稳定性保护：fallback、本地优先可用、默认关闭</h3><ul><li>OpenSearch 检索异常时自动 fallback 到本地检索，避免请求失败。</li><li>OpenSearch ingest 异常仅记日志，不影响本地索引完成更新。</li><li>所有新能力默认开关为 <code>False</code>，采用“显式开启”策略。</li></ul><p>证据锚点：</p><ul><li>检索 fallback：<code>/Users/willfordzhan/Desktop/Work/ats_iot_ai-rag-service/app/rag/retrieval_manager.py:240</code></li><li>ingest 异常降级：<code>/Users/willfordzhan/Desktop/Work/ats_iot_ai-rag-service/app/rag/retrieval_manager.py:198</code></li><li>默认关闭：<code>/Users/willfordzhan/Desktop/Work/ats_iot_ai-rag-service/app/rag/config.py:17</code></li></ul><h2 id="Result（结果）"><a href="#Result（结果）" class="headerlink" title="Result（结果）"></a>Result（结果）</h2><p>功能结果：</p><ol><li>RAG 路由与主链路解耦并可独立启停，满足“可插拔”。</li><li>OpenSearch 双路召回 + RRF + rerank 触发链路完整打通。</li><li>ingest 具备分钟级增量 upsert 与删除同步能力。</li><li>fallback 生效，默认不开启 OpenSearch 依赖。</li><li><code>/ai/runs</code> 主链路回归通过，未出现行为回归。</li></ol><p>证据锚点：</p><ul><li>RAG 初始化失败时降级为空检索器，避免应用启动失败：<code>/Users/willfordzhan/Desktop/Work/ats_iot_ai-rag-service/app/api.py:49</code></li><li><code>/ai/runs</code> 创建&#x2F;事件&#x2F;输入端点存在且逻辑闭环：<code>/Users/willfordzhan/Desktop/Work/ats_iot_ai-rag-service/app/api.py:98</code></li><li><code>/ai/runs</code> 回归测试：<code>/Users/willfordzhan/Desktop/Work/ats_iot_ai-rag-service/tests/test_runs.py:107</code></li></ul><h2 id="验收证据（测试命令与结果）"><a href="#验收证据（测试命令与结果）" class="headerlink" title="验收证据（测试命令与结果）"></a>验收证据（测试命令与结果）</h2><p>执行日期：2026-02-21</p><ol><li>RAG 可插拔核心能力测试</li></ol><ul><li>命令：<code>cd /Users/willfordzhan/Desktop/Work/ats_iot_ai-rag-service &amp;&amp; pytest -q tests/test_rag_retrieval_manager.py tests/test_rag_ingest_scheduler.py tests/test_rerank_trigger.py tests/test_rrf.py</code></li><li>结果摘要：<code>11 passed in 0.15s</code></li><li>覆盖点：fallback、RRF 融合排序、rerank 触发、增量 ingest 行为。</li></ul><ol start="2"><li><code>/ai/runs</code> 主链路回归测试</li></ol><ul><li>命令：<code>cd /Users/willfordzhan/Desktop/Work/ats_iot_ai-rag-service &amp;&amp; pytest -q tests/test_runs.py tests/test_sqlite_store.py</code></li><li>结果摘要：<code>11 passed in 0.50s</code></li><li>覆盖点：run 创建、SSE replay&#x2F;tail、<code>Last-Event-ID</code> 校验、<code>/input</code> 追加、权限隔离。</li></ul><ol start="3"><li>全量回归</li></ol><ul><li>命令：<code>cd /Users/willfordzhan/Desktop/Work/ats_iot_ai-rag-service &amp;&amp; pytest -q</code></li><li>结果摘要：<code>36 passed in 0.64s</code></li></ul><h2 id="风险与假设"><a href="#风险与假设" class="headerlink" title="风险与假设"></a>风险与假设</h2><p>风险：</p><ol><li>当前向量向量化为 <code>pseudo_embedding</code>（占位实现），语义召回上限受限。</li><li>OpenSearch 依赖索引 mapping&#x2F;knn 插件正确配置；若环境不一致会触发 fallback。</li><li>ingest offset 文件是本地文件状态，在多实例并发部署下需做共享状态治理。</li></ol><p>假设：</p><ol><li>生产环境具备可用 OpenSearch 集群与网络连通性。</li><li>文档源（JSON）更新频率与分钟级调度策略匹配。</li><li>rerank 服务后续可替换为真实模型实现（当前默认 <code>Noop</code>）。</li></ol><h2 id="回滚路径"><a href="#回滚路径" class="headerlink" title="回滚路径"></a>回滚路径</h2><p>优先走运行时回滚（无需改代码）：</p><ol><li>关闭 RAG 新能力开关并重启服务：</li></ol><ul><li><code>RAG_OPENSEARCH_ENABLED=false</code></li><li><code>RAG_HYBRID_RRF_ENABLED=false</code></li><li><code>RAG_RERANK_ENABLED=false</code></li><li><code>RAG_INGEST_SCHEDULER_ENABLED=false</code></li></ul><ol start="2"><li>验证 <code>/ai/runs</code> 与 <code>/rag/retrieve</code> 基础可用：</li></ol><ul><li><code>pytest -q tests/test_runs.py tests/test_sqlite_store.py</code></li><li><code>pytest -q tests/test_rag_retrieval_manager.py</code></li></ul><ol start="3"><li>如需代码级回退，回退文件集合：</li></ol><ul><li><code>/Users/willfordzhan/Desktop/Work/ats_iot_ai-rag-service/app/rag/</code></li><li><code>/Users/willfordzhan/Desktop/Work/ats_iot_ai-rag-service/app/api.py</code></li><li><code>/Users/willfordzhan/Desktop/Work/ats_iot_ai-rag-service/tests/test_rag_*</code></li></ul><h2 id="后续改进项（责任人-截止建议）"><a href="#后续改进项（责任人-截止建议）" class="headerlink" title="后续改进项（责任人&#x2F;截止建议）"></a>后续改进项（责任人&#x2F;截止建议）</h2><ol><li><p>接入真实 embedding + reranker 模型，替换占位实现<br>责任人建议：RAG 后端负责人<br>截止建议：2026-03-06</p></li><li><p>增加 OpenSearch 索引模板与启动自检（mapping&#x2F;knn&#x2F;字段一致性）<br>责任人建议：平台&#x2F;运维负责人<br>截止建议：2026-03-01</p></li><li><p>为 ingest 调度补充多实例一致性方案（如 Redis 锁 + 共享 offset）<br>责任人建议：基础架构负责人<br>截止建议：2026-03-08</p></li><li><p>增补线上可观测性：检索命中率、fallback 率、rerank 命中率与时延分位<br>责任人建议：可观测性负责人<br>截止建议：2026-03-10</p></li></ol><h2 id="面试陈述版（60-90秒）"><a href="#面试陈述版（60-90秒）" class="headerlink" title="面试陈述版（60-90秒）"></a>面试陈述版（60-90秒）</h2><p>这轮我主导了 RAG 的可插拔改造，核心目标是“能力升级但不影响主链路”。技术上我把检索抽象成 Manager + Provider：默认本地检索，按开关接入 OpenSearch 双路召回（BM25+向量+过滤），再通过 Hybrid RRF 做融合；同时对 rerank 采用条件触发，只在低置信或复杂问题执行，控制延迟成本。数据侧我补了分钟级增量 ingest + upsert，支持变更与删除同步。稳定性上设计了两层降级：OpenSearch 检索失败回落本地、OpenSearch ingest 失败不影响本地索引。最终验证上，RAG 与主链路测试全部通过：RAG 核心 11 项、<code>/ai/runs</code> 回归 11 项、全量 36 项通过，达成可上线的灰度前置条件。</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI工作日志</tag>
      
      <tag>RAG</tag>
      
      <tag>OpenSearch</tag>
      
      <tag>工程复盘</tag>
      
      <tag>STAR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Customized Spec：我的 AI 开发流程规范（PO/架构师监管 + 多Agent并行）</title>
    <link href="/2026/02/21/customized-spec-ai-po-agent/"/>
    <url>/2026/02/21/customized-spec-ai-po-agent/</url>
    
    <content type="html"><![CDATA[<p>这不是“多加一层流程”，而是把已经在做的事情变成可复用、可审计、可并行扩展的工程规范。</p><h2 id="为什么要做这份-Spec"><a href="#为什么要做这份-Spec" class="headerlink" title="为什么要做这份 Spec"></a>为什么要做这份 Spec</h2><p>过去 AI 研发里最常见的问题不是“模型不够强”，而是：</p><ol><li>需求口径经常漂移，执行层只能边做边猜。</li><li>多个 Agent 并行时，边界不清，返工和冲突频繁。</li><li>结果难复盘，出了问题只能靠个人记忆追责。</li></ol><p>所以我把流程标准化为 <code>Customized Spec</code>：用 PO&#x2F;架构师做监管闭环，用多 Agent 做执行并行，把速度和质量同时拉起来。</p><h2 id="角色分工（监管者-vs-执行者）"><a href="#角色分工（监管者-vs-执行者）" class="headerlink" title="角色分工（监管者 vs 执行者）"></a>角色分工（监管者 vs 执行者）</h2><h3 id="监管者（PO-架构师）"><a href="#监管者（PO-架构师）" class="headerlink" title="监管者（PO&#x2F;架构师）"></a>监管者（PO&#x2F;架构师）</h3><ol><li>定义任务边界、验收标准和优先级。</li><li>拆解里程碑，控制节奏与风险。</li><li>审阅关键设计与关键提交，做 go&#x2F;no-go 决策。</li><li>维护规范资产：模板、检查清单、回滚策略。</li></ol><h3 id="执行者（多-Agent-人类开发者）"><a href="#执行者（多-Agent-人类开发者）" class="headerlink" title="执行者（多 Agent + 人类开发者）"></a>执行者（多 Agent + 人类开发者）</h3><ol><li>按分工并行实现，严格遵守输入输出契约。</li><li>在每个里程碑提交可验证产物（代码&#x2F;文档&#x2F;测试）。</li><li>主动暴露阻塞与风险，不隐性跳过规范步骤。</li><li>通过 PR&#x2F;日志沉淀可追踪证据链。</li></ol><p>核心原则：监管者负责“方向和质量门”，执行者负责“速度和产出密度”。</p><h2 id="端到端七阶段流程"><a href="#端到端七阶段流程" class="headerlink" title="端到端七阶段流程"></a>端到端七阶段流程</h2><ol><li><code>Stage 1 - 任务立项</code>：明确业务目标、范围、约束、验收指标。</li><li><code>Stage 2 - Spec 编制</code>：输出任务 spec，定义角色、接口、风险与回滚方案。</li><li><code>Stage 3 - 架构评审</code>：监管者确认方案可行性与并行切分策略。</li><li><code>Stage 4 - 多 Agent 执行</code>：按子任务并行推进，保持接口一致性。</li><li><code>Stage 5 - 集成验证</code>：合并产物，执行测试与数据回归校验。</li><li><code>Stage 6 - 里程碑发布</code>：按阶段打里程碑 commit，并同步里程碑 blog。</li><li><code>Stage 7 - 复盘沉淀</code>：记录偏差、复用资产、更新规范版本。</li></ol><h2 id="MUST-SHOULD-MUST-NOT-清单"><a href="#MUST-SHOULD-MUST-NOT-清单" class="headerlink" title="MUST &#x2F; SHOULD &#x2F; MUST NOT 清单"></a>MUST &#x2F; SHOULD &#x2F; MUST NOT 清单</h2><h3 id="MUST"><a href="#MUST" class="headerlink" title="MUST"></a>MUST</h3><ol><li>必须先有 spec，再进入编码阶段。</li><li>必须定义监管者与执行者责任边界。</li><li>必须按里程碑提交，且每个里程碑可独立验证。</li><li>必须保留证据链（commit、PR、日志、测试结果）。</li></ol><h3 id="SHOULD"><a href="#SHOULD" class="headerlink" title="SHOULD"></a>SHOULD</h3><ol><li>应优先做高风险项前置验证（PoC&#x2F;烟囱测试）。</li><li>应使用统一模板减少沟通成本。</li><li>应在每日&#x2F;每阶段结束时同步状态快照。</li><li>应在复盘中输出可复用“反模式清单”。</li></ol><h3 id="MUST-NOT"><a href="#MUST-NOT" class="headerlink" title="MUST NOT"></a>MUST NOT</h3><ol><li>禁止无 spec 直接大规模编码。</li><li>禁止跨角色越权决策（执行者直接改需求口径）。</li><li>禁止里程碑前一次性堆积提交。</li><li>禁止发布后不做复盘闭环。</li></ol><h2 id="YAML-模板片段"><a href="#YAML-模板片段" class="headerlink" title="YAML 模板片段"></a>YAML 模板片段</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">customized_spec:</span><br>  <span class="hljs-attr">meta:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;任务名称&quot;</span><br>    <span class="hljs-attr">owner:</span> <span class="hljs-string">&quot;监管者(PO/架构师)&quot;</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-string">&quot;v1.0&quot;</span><br>  <span class="hljs-attr">goal:</span><br>    <span class="hljs-attr">business_objective:</span> <span class="hljs-string">&quot;业务目标&quot;</span><br>    <span class="hljs-attr">acceptance_criteria:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;验收条件1&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;验收条件2&quot;</span><br>  <span class="hljs-attr">roles:</span><br>    <span class="hljs-attr">supervisor:</span><br>      <span class="hljs-attr">responsibilities:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;范围与优先级裁决&quot;</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;关键设计审批&quot;</span><br>    <span class="hljs-attr">executors:</span><br>      <span class="hljs-attr">responsibilities:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;并行实现&quot;</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;测试与证据提交&quot;</span><br>  <span class="hljs-attr">milestones:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">&quot;M1&quot;</span><br>      <span class="hljs-attr">output:</span> <span class="hljs-string">&quot;spec + 架构评审记录&quot;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">&quot;M2&quot;</span><br>      <span class="hljs-attr">output:</span> <span class="hljs-string">&quot;核心功能可运行&quot;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">&quot;M3&quot;</span><br>      <span class="hljs-attr">output:</span> <span class="hljs-string">&quot;集成验收 + 发布说明&quot;</span><br>  <span class="hljs-attr">guardrails:</span><br>    <span class="hljs-attr">must:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;先spec后编码&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;里程碑可验证&quot;</span><br>    <span class="hljs-attr">must_not:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;无审查直接发布&quot;</span><br></code></pre></td></tr></table></figure><h2 id="立即生效的执行约定（里程碑-Commit-里程碑-Blog）"><a href="#立即生效的执行约定（里程碑-Commit-里程碑-Blog）" class="headerlink" title="立即生效的执行约定（里程碑 Commit + 里程碑 Blog）"></a>立即生效的执行约定（里程碑 Commit + 里程碑 Blog）</h2><p>从今天开始，所有 AI 开发任务执行以下硬约定：</p><ol><li>每个里程碑至少一个可追踪 commit，commit message 统一包含里程碑编号（如 <code>M2:</code>）。</li><li>每完成一个关键里程碑，产出一篇里程碑 blog（记录目标、产出、风险、下一步）。</li><li>里程碑 blog 不是“总结文档”，而是监管与协同接口，必须具备可审计性。</li><li>未满足“里程碑 commit + 里程碑 blog”双条件，不视为阶段完成。</li></ol><p>这份 <code>Customized Spec</code> 不是一次性文档，而是持续演进的团队操作系统。</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI工作日志</tag>
      
      <tag>Spec</tag>
      
      <tag>PO</tag>
      
      <tag>架构</tag>
      
      <tag>Multi-Agent</tag>
      
      <tag>工程流程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>里程碑进展：Orchestrator 动态范式编排（Plan-and-Solve / ReAct / Reflection）落地</title>
    <link href="/2026/02/20/orchestrator-plan-and-solve-react-reflection/"/>
    <url>/2026/02/20/orchestrator-plan-and-solve-react-reflection/</url>
    
    <content type="html"><![CDATA[<p>动态范式 Orchestrator 改造完成，本文记录本轮里程碑的目标、交付、兼容性与下一步计划。</p><h2 id="1-里程碑目标"><a href="#1-里程碑目标" class="headerlink" title="1) 里程碑目标"></a>1) 里程碑目标</h2><ul><li>将单路径编排升级为“按意图动态选择策略”的多范式执行框架。</li><li>在不破坏既有事件契约的前提下，引入 Plan-and-Solve &#x2F; ReAct &#x2F; Reflection 三类策略能力。</li><li>补齐可观测链路，支撑后续运行质量评估与策略演进。</li></ul><h2 id="2-本次完成内容（按模块）"><a href="#2-本次完成内容（按模块）" class="headerlink" title="2) 本次完成内容（按模块）"></a>2) 本次完成内容（按模块）</h2><h3 id="Intent-Router-Policy-Engine"><a href="#Intent-Router-Policy-Engine" class="headerlink" title="Intent Router + Policy Engine"></a>Intent Router + Policy Engine</h3><ul><li>新增意图识别层：将输入路由为 <code>TOOL_CALL</code> &#x2F; <code>TRACE_DIAGNOSIS</code> &#x2F; <code>GENERAL_QA</code> 等意图。</li><li>新增策略决策层：基于意图映射到执行策略（如 ReAct、Plan-and-Solve），并输出决策原因与元数据。</li><li>支持工具调用意图中 <code>tool:&lt;name&gt; &lt;json&gt;</code> 结构化参数解析，并保留失败兜底语义。</li></ul><h3 id="Strategy-Executors-Runtime-Guard-Eval-Loop"><a href="#Strategy-Executors-Runtime-Guard-Eval-Loop" class="headerlink" title="Strategy Executors + Runtime Guard + Eval Loop"></a>Strategy Executors + Runtime Guard + Eval Loop</h3><ul><li>新增策略执行器集合：按策略统一实现 <code>run(context)</code>，输出标准化结果。</li><li>新增 Runtime Guard：对策略结果做运行期约束校验（字段完整性、状态一致性、失败传播）。</li><li>新增 Eval Loop：支持策略链路尝试、trace 记录与终止条件控制，为 Reflection 回退提供基础。</li></ul><h3 id="Orchestrator-主流程集成"><a href="#Orchestrator-主流程集成" class="headerlink" title="Orchestrator 主流程集成"></a>Orchestrator 主流程集成</h3><ul><li>将 Intent Router、Policy Engine、Strategy Executors、Eval Loop 组装进主流程。</li><li>在主流程中新增意图&#x2F;策略&#x2F;trace 事件发射，并保持终态收敛逻辑一致。</li><li>打通策略输出到 <code>tool_call/tool_result/final</code> 的统一落库路径，确保事件序列可重放、可追踪。</li></ul><h2 id="3-关键代码路径（带文件路径）"><a href="#3-关键代码路径（带文件路径）" class="headerlink" title="3) 关键代码路径（带文件路径）"></a>3) 关键代码路径（带文件路径）</h2><ul><li><code>app/orchestration/intent_router.py</code></li><li><code>app/orchestration/policy_engine.py</code></li><li><code>app/orchestration/strategies.py</code></li><li><code>app/orchestration/runtime_guard.py</code></li><li><code>app/orchestration/eval_loop.py</code></li><li><code>app/orchestration/types.py</code></li><li><code>app/orchestrator.py</code></li><li><code>tests/orchestrator/test_intent_policy.py</code></li><li><code>tests/orchestrator/test_strategies.py</code></li><li><code>tests/orchestrator/test_orchestrator_integration.py</code></li></ul><h2 id="4-行为兼容性说明"><a href="#4-行为兼容性说明" class="headerlink" title="4) 行为兼容性说明"></a>4) 行为兼容性说明</h2><p>本次改造严格保留既有关键事件语义与可消费性，不破坏下游 SSE&#x2F;UI&#x2F;存储侧处理逻辑。保留事件包括：</p><ul><li><code>run_started</code></li><li><code>user_message</code></li><li><code>tool_call</code></li><li><code>tool_result</code></li><li><code>final</code></li><li><code>run_failed</code></li></ul><p>兼容性原则：</p><ul><li>新能力在原契约上“增量扩展”，而非重定义。</li><li>终态事件仍以 <code>final</code> &#x2F; <code>run_failed</code> 收敛。</li><li><code>tool_call</code> 与 <code>tool_result</code> 的关联字段（如 <code>toolCallId</code>）持续可用。</li></ul><h2 id="5-新增可观测事件"><a href="#5-新增可观测事件" class="headerlink" title="5) 新增可观测事件"></a>5) 新增可观测事件</h2><p>在兼容原有事件的基础上，新增以下可观测事件用于策略链路诊断：</p><ul><li><code>intent_determined</code>：记录识别出的意图、判定原因与辅助元数据。</li><li><code>policy_decision</code>：记录策略选择结果、选择理由与策略元信息。</li><li><code>trace</code>：记录每步策略执行轨迹（<code>strategy</code>、<code>ok</code>、<code>reason</code>、<code>durationMs</code>、<code>metadata</code>）。</li></ul><h2 id="6-测试与验收结果"><a href="#6-测试与验收结果" class="headerlink" title="6) 测试与验收结果"></a>6) 测试与验收结果</h2><ul><li><code>pytest</code> 全量：<code>36 passed, 1 warning</code></li><li>覆盖范围包含：</li><li>意图解析与策略决策单测</li><li>策略执行器 &#x2F; Guard &#x2F; Eval Loop 行为单测</li><li>Orchestrator 端到端集成测试（含事件顺序与关联字段校验）</li></ul><h2 id="7-关联-commit-列表"><a href="#7-关联-commit-列表" class="headerlink" title="7) 关联 commit 列表"></a>7) 关联 commit 列表</h2><ul><li><code>7c51a83 feat(orchestrator): add intent router and policy engine</code></li><li><code>2ade778 feat(orchestrator): add strategy executors and runtime guard</code></li><li><code>54359f4 feat(orchestrator): integrate dynamic strategy pipeline</code></li></ul><h2 id="8-下一步计划（v2）"><a href="#8-下一步计划（v2）" class="headerlink" title="8) 下一步计划（v2）"></a>8) 下一步计划（v2）</h2><ul><li>policy 可配置化（tenant 级）</li><li>trace 指标沉淀到可视化面板</li><li>真实 LLM planner 接入</li></ul>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI工作日志</tag>
      
      <tag>MCP</tag>
      
      <tag>ReAct</tag>
      
      <tag>Orchestrator</tag>
      
      <tag>Plan-and-Solve</tag>
      
      <tag>Reflection</tag>
      
      <tag>里程碑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dify 还是自研 RAG：铸造 MES/ERP 场景的架构共创与落地计划</title>
    <link href="/2026/02/20/dify-rag-mes-erp/"/>
    <url>/2026/02/20/dify-rag-mes-erp/</url>
    
    <content type="html"><![CDATA[<h2 id="背景与目标"><a href="#背景与目标" class="headerlink" title="背景与目标"></a>背景与目标</h2><p>本篇用于把一次“Dify vs 自研 RAG”的架构讨论整理成可复盘记录，避免后续只记结论、不记前提。</p><p>讨论前提：</p><ol><li>已完成一轮 Python AI 控制面重构。</li><li>需要快速接入铸造行业知识库能力。</li><li>同时满足“生产可用”和“可作为面试项目叙事”两类目标。</li><li>数据来源复杂（公众号、书籍、工艺参数文档、行业文档），噪声高、知识密度高。</li><li>业务并行存在 MES 实时数据工具调用 + 行业知识问答两类请求。</li></ol><p>本轮目标：</p><ol><li>明确路线：Dify、纯自研、混合三种方案中怎么选。</li><li>明确策略：Agent 策略如何收敛，避免“策略堆叠”。</li><li>明确工程门禁：如何防止“看起来能答、上线后不稳定”。</li></ol><h2 id="决策记录（Decision-Log）"><a href="#决策记录（Decision-Log）" class="headerlink" title="决策记录（Decision Log）"></a>决策记录（Decision Log）</h2><h3 id="尖锐结论（4-条）"><a href="#尖锐结论（4-条）" class="headerlink" title="尖锐结论（4 条）"></a>尖锐结论（4 条）</h3><p>a. 瓶颈在 <strong>数据清洗 + chunk 策略 + 检索过滤 + 评测集</strong>，不是 Agent 花样。<br>b. 最优路线是 <strong>“自研检索内核 + 现有 Python Control Plane + 可选 Dify External Knowledge API”</strong>。<br>c. Agent 策略收敛为：<strong>ReAct 默认；Plan-and-solve 仅复杂任务；Reflection 仅低置信&#x2F;高风险触发</strong>。<br>d. 没有 <strong>Gold Set（金标问答）+ 回归门禁</strong>，系统很容易“看起来能答但不稳定”。  </p><h3 id="最该先拍板的-10-个问题（完整列出）"><a href="#最该先拍板的-10-个问题（完整列出）" class="headerlink" title="最该先拍板的 10 个问题（完整列出）"></a>最该先拍板的 10 个问题（完整列出）</h3><ol><li>数据合规先不管，能不能先做？</li><li>如果增强效果需要上新基础设施，可以加吗？</li><li>数据量 <code>&lt;= 20G</code>、QPS <code>50~500</code>，整体怎么设计？</li><li>先用 Qwen 最强模型验证效果，后续再谈成本，是否可行？</li><li>Reranker 私有部署和公有部署的关键区别是什么？</li><li>ACL 是什么？在 RAG 链路里放在哪一层？</li><li>数据更新要分钟级，能支持吗？</li><li>Dify 和自研双接入是否推荐？</li><li>什么是金标问答？为什么必须做？</li><li>低置信时策略怎么定？</li></ol><h3 id="KEY-CONTENTS"><a href="#KEY-CONTENTS" class="headerlink" title="KEY CONTENTS"></a>KEY CONTENTS</h3><p>你的这 10 条反馈非常关键，基于它我给出一个更落地的结论：</p><pre><code class="hljs">1. 路线定型- 采用“双线并行”：自研 RAG Retrieval API + Dify External Knowledge API 同时接入。- 在线主链路：Python Agent 调你自研检索服务；Dify 作为并行入口与备份编排入口。- 这条路兼顾“快出效果”和“长期可控”。2. 尖锐提醒（必须直说）- 4核8G + 无GPU 想稳定跑高质量本地 reranker + 50~500 QPS，现实上很吃力。- 你可以先用 Qwen 最强模型做效果验证，但生产一定要做“分级策略+缓存+降级”，否则成本和时延会失控。- 真正决定效果的，不是 Agent 名字，而是数据清洗、chunk、过滤和评测集。3. 你问的关键点回答- ACL 是什么：Access Control List，访问控制列表。  在你场景里就是“谁能检索到哪些文档/片段”。最小粒度建议到 chunk，至少带 tenant_dept_id、visibility_level、  role_scope。- 私有 vs 公有 reranker：  公有API优点是快上线、质量通常更高、无算力压力；缺点是网络时延、调用成本、限流。  私有部署优点是可控和数据不出域；缺点是你当前机器配置下吞吐偏低，维护成本更高。  你的现状建议：先公有API reranker验证效果 -&gt; 后续再评估私有化。- 金标问答是啥，为什么能提升效果：  金标问答不是 few-shot。  它是“评测基准集”，用于客观判断你每次改动到底变好还是变坏。  没有金标集，RAG 调优基本是拍脑袋。4. 金标问答样例（非本行业示例）&#123;  &quot;id&quot;: &quot;qa_001&quot;,  &quot;question&quot;: &quot;锅炉水质硬度超标会导致什么问题？&quot;,  &quot;answerable&quot;: true,  &quot;expected_doc_ids&quot;: [&quot;doc_chem_12&quot;, &quot;doc_ops_03&quot;],  &quot;must_include_points&quot;: [    &quot;结垢风险&quot;,    &quot;换热效率下降&quot;,    &quot;能耗上升&quot;  ],  &quot;must_not_include_points&quot;: [    &quot;与硬度无关的结论&quot;  ]&#125;&#123;  &quot;id&quot;: &quot;qa_002&quot;,  &quot;question&quot;: &quot;2030版某标准中新增了哪些条款？&quot;,  &quot;answerable&quot;: false,  &quot;expected_doc_ids&quot;: [],  &quot;must_include_points&quot;: [    &quot;当前知识库证据不足&quot;  ]&#125;5. 按你约束后的推荐技术方案- 检索引擎：OpenSearch（支持 BM25 + 向量 + 过滤）。- 检索策略：Hybrid Recall（BM25 + Dense）+ RRF 融合。- Rerank策略：只对复杂/低置信问题启用。- 更新策略：分钟级增量（队列化 ingest + upsert index）。- 回答策略：你已定的“追问 + 风险提示回答”，非常正确。- Agent策略：默认 ReAct；复杂任务再开 Plan-and-Solve；Reflection 只在低置信触发。</code></pre><h3 id="关键决策结论（按讨论时间固化）"><a href="#关键决策结论（按讨论时间固化）" class="headerlink" title="关键决策结论（按讨论时间固化）"></a>关键决策结论（按讨论时间固化）</h3><table><thead><tr><th>日期</th><th>决策项</th><th>结论</th></tr></thead><tbody><tr><td>2026-02-20</td><td>路线选择</td><td>采用混合路线，不做纯 Dify&#x2F;纯自研二选一。</td></tr><tr><td>2026-02-20</td><td>能力分层</td><td>Dify 负责流程编排试错；检索上限由自研内核负责。</td></tr><tr><td>2026-02-20</td><td>Agent 策略</td><td>ReAct 默认；Plan-and-solve 和 Reflection 改为按条件触发。</td></tr><tr><td>2026-02-20</td><td>质量门禁</td><td>必须建设 Gold Set 与回归评测，禁止“凭感觉调参上线”。</td></tr></tbody></table><h2 id="Q-A-纪要（含用户原始输入）"><a href="#Q-A-纪要（含用户原始输入）" class="headerlink" title="Q&amp;A 纪要（含用户原始输入）"></a>Q&amp;A 纪要（含用户原始输入）</h2><p>以下 10 条“用户原始输入 + 用户回答”按讨论记录完整保留，不做摘要改写。</p><h3 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h3><p>用户原始输入：数据合规先不管，能不能先做？<br>用户回答（完整保留）：可以先做验证版，但建议保留文档来源和版本元数据，后续补治理时不会返工。</p><h3 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h3><p>用户原始输入：如果增强效果需要上新基础设施，可以加吗？<br>用户回答（完整保留）：可以。建议优先上支持混合检索的引擎（如 OpenSearch）。</p><h3 id="Q3"><a href="#Q3" class="headerlink" title="Q3"></a>Q3</h3><p>用户原始输入：数据量 <code>&lt;= 20G</code>，QPS <code>50~500</code>，怎么设计？<br>用户回答（完整保留）：这个规模下，核心不在“能不能跑”，而在“高峰稳定和检索质量可回归”。需要缓存、分级策略和压测门禁。</p><h3 id="Q4"><a href="#Q4" class="headerlink" title="Q4"></a>Q4</h3><p>用户原始输入：先用 Qwen 最强模型验证效果，后续再谈成本，是否可行？<br>用户回答（完整保留）：可行，且是正确顺序。先做质量上限验证，再做成本优化和模型分层。</p><h3 id="Q5"><a href="#Q5" class="headerlink" title="Q5"></a>Q5</h3><p>用户原始输入：Reranker 私有部署和公有部署区别？<br>用户回答（完整保留）：</p><p>公有部署：上线快、质量通常更好、免运维，但有调用成本和外部延迟。<br>私有部署：数据与服务更可控，但你当前 <code>4核8G + 无GPU</code> 条件下吞吐会受限。<br>建议：<strong>先公有验证，后私有评估</strong>。</p><h3 id="Q6"><a href="#Q6" class="headerlink" title="Q6"></a>Q6</h3><p>用户原始输入：ACL 是什么？<br>用户回答（完整保留）：ACL（Access Control List）是访问控制列表。在 RAG 里就是“谁能检索到哪些文档&#x2F;片段”的硬约束，必须在召回阶段就生效。</p><h3 id="Q7"><a href="#Q7" class="headerlink" title="Q7"></a>Q7</h3><p>用户原始输入：数据更新要分钟级，能支持吗？<br>用户回答（完整保留）：能。需要增量 ingest + upsert 索引 + 任务队列，避免全量重建。</p><h3 id="Q8"><a href="#Q8" class="headerlink" title="Q8"></a>Q8</h3><p>用户原始输入：Dify 和自研双接入是否推荐？<br>用户回答（完整保留）：推荐。这正是当前阶段“快 + 稳 + 可扩展”的最优策略。</p><h3 id="Q9"><a href="#Q9" class="headerlink" title="Q9"></a>Q9</h3><p>用户原始输入：什么是金标问答？为什么必须做？<br>用户回答（完整保留）：金标问答不是 few-shot，它是评测基准集。作用是客观评估“改了检索策略后是否真的变好”，避免调参靠感觉。</p><p>金标样例（非行业）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;qa_001&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;question&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;锅炉水质硬度超标会导致什么问题？&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;answerable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;expected_doc_ids&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;doc_chem_12&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;doc_ops_03&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;must_include_points&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;结垢风险&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;换热效率下降&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;能耗上升&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="Q10"><a href="#Q10" class="headerlink" title="Q10"></a>Q10</h3><p>用户原始输入：低置信时策略怎么定？<br>用户回答（完整保留）：采用“<strong>追问 + 带风险提示回答</strong>”。这是兼顾可用性与安全性的合理策略。</p><h2 id="术语解释（4-个）"><a href="#术语解释（4-个）" class="headerlink" title="术语解释（4 个）"></a>术语解释（4 个）</h2><h3 id="Hybrid-Retrieval"><a href="#Hybrid-Retrieval" class="headerlink" title="Hybrid Retrieval"></a>Hybrid Retrieval</h3><p>同一查询同时做关键词召回（BM25 等）和向量召回，再做融合排序。目标是兼顾“术语精确命中”和“语义相近召回”。</p><h3 id="Reranker"><a href="#Reranker" class="headerlink" title="Reranker"></a>Reranker</h3><p>对初步召回结果做二次排序的模型&#x2F;服务。它不负责“广撒网召回”，主要负责“把更相关结果排到前面”。</p><h3 id="Reflection-Gating"><a href="#Reflection-Gating" class="headerlink" title="Reflection Gating"></a>Reflection Gating</h3><p>不是全量反思，而是“按门控触发反思”：仅在低置信度、高风险问题时触发，避免时延与成本失控。</p><h3 id="Gold-Set"><a href="#Gold-Set" class="headerlink" title="Gold Set"></a>Gold Set</h3><p>用于评测的金标问答集，不是提示词样例。核心用途是做离线评测和回归门禁，验证系统改动是否真实提升。</p><h2 id="基于-10-条回答的落地结论"><a href="#基于-10-条回答的落地结论" class="headerlink" title="基于 10 条回答的落地结论"></a>基于 10 条回答的落地结论</h2><h3 id="路线定型"><a href="#路线定型" class="headerlink" title="路线定型"></a>路线定型</h3><p>路线正式定为：<strong>自研检索内核 + 现有 Python Control Plane + 可选 Dify External Knowledge API</strong>。<br>这保证了短期上线速度与长期可控上限兼得。</p><h3 id="尖锐提醒"><a href="#尖锐提醒" class="headerlink" title="尖锐提醒"></a>尖锐提醒</h3><p>如果先投入大量时间做 Agent 花样，而没有先稳定“清洗、切分、检索过滤、评测集”，上线后会出现“个别案例惊艳、整体稳定性不足”的典型反模式。</p><h3 id="关键问答解释（影响实现优先级）"><a href="#关键问答解释（影响实现优先级）" class="headerlink" title="关键问答解释（影响实现优先级）"></a>关键问答解释（影响实现优先级）</h3><ol><li>Q4 明确“先上限后成本”：先用强模型验证能力上限，再做分层降本。  </li><li>Q5 明确“先公有后私有”：在 <code>4核8G + 无GPU</code> 资源约束下，先用公有 reranker 更稳妥。  </li><li>Q7 明确“分钟级更新要靠增量链路”：必须做 ingest 增量化与 upsert，不能靠全量重建。  </li><li>Q9&#x2F;Q10 明确“必须可评测 + 可兜底”：有金标、有门禁、有低置信策略，才是生产系统。</li></ol><h3 id="金标样例（用于回归评测）"><a href="#金标样例（用于回归评测）" class="headerlink" title="金标样例（用于回归评测）"></a>金标样例（用于回归评测）</h3><p>以下样例沿用 Q9 讨论，用于说明 Gold Set 的结构要求：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;qa_001&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;question&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;锅炉水质硬度超标会导致什么问题？&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;answerable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;expected_doc_ids&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;doc_chem_12&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;doc_ops_03&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;must_include_points&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;结垢风险&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;换热效率下降&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;能耗上升&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="推荐技术方案（由-Q-A-反推）"><a href="#推荐技术方案（由-Q-A-反推）" class="headerlink" title="推荐技术方案（由 Q&amp;A 反推）"></a>推荐技术方案（由 Q&amp;A 反推）</h3><ol><li>检索：<code>Hybrid Retrieval + ACL 过滤 + 条件触发 reranker</code>。  </li><li>编排：Python Control Plane 承担主链路编排与工具路由。  </li><li>对接：保留 Dify External Knowledge API 作为可选知识入口。  </li><li>评测：Gold Set + 回归门禁（Recall@K、citation 覆盖率、低置信策略命中率、P95 时延）。</li></ol><h2 id="架构方案与阶段计划"><a href="#架构方案与阶段计划" class="headerlink" title="架构方案与阶段计划"></a>架构方案与阶段计划</h2><h3 id="架构分层（生产口径）"><a href="#架构分层（生产口径）" class="headerlink" title="架构分层（生产口径）"></a>架构分层（生产口径）</h3><ol><li>接入层：Dify 编排入口（快速试错）+ Python Agent 入口（主生产路径）。  </li><li>检索层（自研内核）：解析&#x2F;清洗&#x2F;切分、混合召回、ACL 过滤、reranker、证据引用。  </li><li>决策层：默认 ReAct；复杂任务才启用 Plan-and-solve；低置信&#x2F;高风险才启用 Reflection。  </li><li>评测与观测层：Gold Set 回归评测、线上指标告警、链路可追踪。</li></ol><h3 id="阶段计划（沿用原讨论节奏）"><a href="#阶段计划（沿用原讨论节奏）" class="headerlink" title="阶段计划（沿用原讨论节奏）"></a>阶段计划（沿用原讨论节奏）</h3><h4 id="Phase-1（2-3-周）：先跑通效果"><a href="#Phase-1（2-3-周）：先跑通效果" class="headerlink" title="Phase 1（2~3 周）：先跑通效果"></a>Phase 1（2~3 周）：先跑通效果</h4><ol><li>建立最小 ingest pipeline（解析&#x2F;清洗&#x2F;切分&#x2F;元数据）。  </li><li>上线 <code>Hybrid Retrieval</code>（关键词 + 向量）与基础过滤。  </li><li>输出可引用证据（chunk&#x2F;doc 引用 ID）。</li></ol><h4 id="Phase-2（3-5-周）：提升稳定性"><a href="#Phase-2（3-5-周）：提升稳定性" class="headerlink" title="Phase 2（3~5 周）：提升稳定性"></a>Phase 2（3~5 周）：提升稳定性</h4><ol><li>加 reranker（按复杂度和置信度触发）。  </li><li>建立分钟级增量更新链路。  </li><li>建立缓存与限流，控制峰值时延。</li></ol><h4 id="Phase-3（5-8-周）：工程化闭环"><a href="#Phase-3（5-8-周）：工程化闭环" class="headerlink" title="Phase 3（5~8 周）：工程化闭环"></a>Phase 3（5~8 周）：工程化闭环</h4><ol><li>建立金标问答集和离线评测流水线。  </li><li>对接 Dify External Knowledge API 与 Python Agent 双入口。  </li><li>做回归门禁（Recall@K、citation 覆盖率、低置信策略命中率、P95 时延）。</li></ol><h2 id="风险与反模式"><a href="#风险与反模式" class="headerlink" title="风险与反模式"></a>风险与反模式</h2><ol><li>反模式：过早追求 Agent 复杂策略，忽略数据清洗与 chunk 质量。<br>风险：线上结果波动大、复现困难。</li><li>反模式：没有 Gold Set 和回归门禁就频繁改策略。<br>风险：每次优化都可能隐性退化。</li><li>反模式：ACL 后置到生成阶段才做。<br>风险：召回阶段即发生越权风险。</li><li>反模式：分钟级更新诉求仍走全量重建。<br>风险：索引延迟不可控，资源浪费。</li><li>反模式：低置信场景不给追问&#x2F;风险提示。<br>风险：系统“答得很满但不可靠”。</li></ol><h2 id="后续行动项（Owner-截止）"><a href="#后续行动项（Owner-截止）" class="headerlink" title="后续行动项（Owner&#x2F;截止）"></a>后续行动项（Owner&#x2F;截止）</h2><table><thead><tr><th>行动项</th><th>Owner</th><th>截止</th></tr></thead><tbody><tr><td>形成 <code>Gold Set v1</code>（至少覆盖上述 10 个高频问题）</td><td>业务专家 + AI 平台（待指派）</td><td>2026-02-27</td></tr><tr><td>打通增量 ingest + upsert（分钟级更新）</td><td>数据接入负责人（待指派）</td><td>2026-03-06</td></tr><tr><td>完成 Hybrid Retrieval + ACL 召回前置</td><td>检索内核负责人（待指派）</td><td>2026-03-13</td></tr><tr><td>上线条件触发 reranker 与低置信兜底策略</td><td>推理编排负责人（待指派）</td><td>2026-03-20</td></tr><tr><td>建立回归门禁（Recall@K &#x2F; citation &#x2F; P95）并接入发布流程</td><td>评测与平台工程负责人（待指派）</td><td>2026-03-27</td></tr></tbody></table><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在铸造 MES&#x2F;ERP 场景，真正决定成败的不是 Agent 名字，而是数据管道质量、检索过滤设计、评测回归体系。<br>先把这三件事做扎实，RAG 才能从 Demo 变成稳定生产能力。</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI工作日志</tag>
      
      <tag>MCP</tag>
      
      <tag>AI工程</tag>
      
      <tag>RAG</tag>
      
      <tag>Dify</tag>
      
      <tag>架构设计</tag>
      
      <tag>知识库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>里程碑进展：Java AI 模块配置与依赖清理（MCP 版）</title>
    <link href="/2026/02/20/java-ai-mcp-cleanup-milestone/"/>
    <url>/2026/02/20/java-ai-mcp-cleanup-milestone/</url>
    
    <content type="html"><![CDATA[<h2 id="里程碑范围"><a href="#里程碑范围" class="headerlink" title="里程碑范围"></a>里程碑范围</h2><p>本次里程碑聚焦 Java 侧 AI 模块的“减法治理”：明确 MCP 方案的保留项，移除历史遗留配置与依赖，降低维护复杂度并收敛运行面。</p><h2 id="配置清理结果（YAML）"><a href="#配置清理结果（YAML）" class="headerlink" title="配置清理结果（YAML）"></a>配置清理结果（YAML）</h2><p>在本地 YAML 配置中，已完成 MCP-only 重构的配置收口：</p><ol><li>删除历史遗留且已废弃的配置段：<code>ai.model</code>、<code>ai.store</code>、<code>ai.prompt</code>、<code>ai.archive</code>。</li><li>保留当前仍在使用的配置段：<code>ai.mcp</code>、<code>ai.dify</code>。</li><li>结果：配置语义与当前架构一致，避免“看得见但不会生效”的伪配置继续干扰排查。</li></ol><h2 id="依赖清理结果（POM）"><a href="#依赖清理结果（POM）" class="headerlink" title="依赖清理结果（POM）"></a>依赖清理结果（POM）</h2><p>在 <code>pom</code> 依赖中，已完成未使用 legacy AI 依赖剔除：</p><ol><li>移除：<code>langchain4j-dashscope</code>、<code>langchain4j-open-ai</code>。</li><li>保留：<code>langchain4j</code> 核心能力（按当前实现需要）与 <code>dashscope-sdk-java</code>（在需要的位置继续使用）。</li><li>结果：依赖树更干净，后续升级与漏洞治理成本下降。</li></ol><h2 id="验证结论"><a href="#验证结论" class="headerlink" title="验证结论"></a>验证结论</h2><p>已执行编译验证命令并通过：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mvn -pl ruoyi-admin -am -DskipTests compile<br></code></pre></td></tr></table></figure><p>这说明本次“配置 + 依赖”清理在当前里程碑范围内未引入编译级回归。</p><h2 id="当前验收状态"><a href="#当前验收状态" class="headerlink" title="当前验收状态"></a>当前验收状态</h2><p>当前里程碑验收状态：<strong>已通过（范围内通过）</strong>。</p><p>说明：</p><ol><li>MCP 方向相关配置与依赖清理目标已达成。</li><li>编译链路已验证可通过。</li><li>全量测试基线仍存在历史遗留的无关失败项，本次不作为阻塞项。</li></ol><h2 id="下一步计划"><a href="#下一步计划" class="headerlink" title="下一步计划"></a>下一步计划</h2><ol><li>建立并收敛一版“可重复”的全量测试基线，先对历史失败做归因分层（本次改动相关 &#x2F; 无关）。</li><li>在 CI 中补充针对 AI 模块的最小回归检查（至少覆盖配置加载、关键 Bean 初始化、核心调用链烟测）。</li><li>持续推进 legacy 残留项扫描，避免后续分支再次引入已移除依赖或配置段。</li></ol>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>AI工作日志</tag>
      
      <tag>MCP</tag>
      
      <tag>AI工程</tag>
      
      <tag>里程碑</tag>
      
      <tag>依赖治理</tag>
      
      <tag>配置清理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态范式编排：Plan-and-Solve + ReAct + Reflection 在 MCP AI 控制平面上的优化</title>
    <link href="/2026/02/20/dynamic-paradigm-orchestrator-optimization/"/>
    <url>/2026/02/20/dynamic-paradigm-orchestrator-optimization/</url>
    
    <content type="html"><![CDATA[<p>本文围绕现有 Java MCP 工具执行层与 Python 控制平面之间的联动，先梳理当前实现快照，再提出一套以 Plan-and-Solve、ReAct 与 Reflection 为基础的动态范式编排优化方案，最终形成可复盘的执行路线、灰度策略与风险表。</p><h2 id="当前实现快照"><a href="#当前实现快照" class="headerlink" title="当前实现快照"></a>当前实现快照</h2><h3 id="Java-MCP-工具链路"><a href="#Java-MCP-工具链路" class="headerlink" title="Java MCP 工具链路"></a>Java MCP 工具链路</h3><p>Java 侧已经打通了内部 MCP 入口：<code>AiMcpEntryService</code>（<code>atsi-iot/atsi-iot-business/.../AiMcpEntryService.java</code>）负责内部 Token 校验 + authz-lite + 分发；后续交给 <code>AiMcpToolDispatcher</code>（<code>.../dispatcher/AiMcpToolDispatcher.java</code>）生成 <code>ToolCall</code>、记录 <code>runId</code>&#x2F;<code>toolCallId</code>、捕获异常并接入 <code>AiMcpToolInvokeLogger</code> 审计。在 <code>AiMcpToolDispatcher</code> 调用的 <code>ToolExecutor</code>（<code>.../tools/ToolExecutor.java</code>）里继续做白名单查找、参数校验、<code>AiToolRuntimeContext</code> 透传，最终调用各类业务工具（<code>ai/tools/impl</code>），保证工具执行在执行平面可以围绕 <code>runId</code> 做统一治理。</p><h3 id="Python-控制平面与编排"><a href="#Python-控制平面与编排" class="headerlink" title="Python 控制平面与编排"></a>Python 控制平面与编排</h3><p><code>app/api.py</code> 负责 <code>POST /ai/runs</code>、<code>/ai/runs/&#123;runId&#125;/events</code> 与 <code>/input</code> 等对外接口，借助 <code>HeaderAuthMiddleware</code> 绑定租户与用户信息并传给 <code>RunStore</code>。<code>Orchestrator</code>（<code>app/orchestrator.py</code>）通过 <code>enqueue</code> 接住用户 query，里面的 <code>_try_parse_tool_call</code> 尝试解析 <code>tool:name &#123;args&#125;</code>，若成功依赖 <code>MCPClient</code>（<code>app/mcp_client.py</code>）先 call <code>/tools/list</code> 再 <code>/tools/call</code>，把事件写入 <code>RunStore</code>，并触发 <code>tool_call/tool_result/final</code> 事件。这个控制平面已经支持异步运行、重复调度、工具能力可扩展，并且保留了继续插入 Planner&#x2F;Reflection 的出口。</p><h3 id="SSE-会话持久化"><a href="#SSE-会话持久化" class="headerlink" title="SSE &#x2F; 会话持久化"></a>SSE &#x2F; 会话持久化</h3><p><code>RunStore</code>（<code>app/store.py</code>）在内存与 SQLite 两种实现间可切换，<code>create_run</code> 保留幂等索引，<code>append_event</code> 按 <code>event_id</code> 递增写入 <code>events</code> 列表或 <code>run_events</code> 表。<code>SQLiteRunStore</code> 利用 WAL、索引保证顺序，将每次 <code>tool_call/tool_result</code> 的 <code>data</code> JSON 结构化存储。<code>/ai/runs/&#123;runId&#125;/events</code> 用 <code>StreamingResponse</code> + 队列（<code>SubscriberQueue</code>）发送历史事件并 tail，队列满时会发送 <code>SubscriberOverflow</code> 并清理；<code>Last-Event-ID</code> 支持断点续传，核心代码在 <code>app/api.py</code> 的 <code>event_generator</code>。这种设计为未来的 trace、Replay 与可观测性打下基础。</p><h3 id="Debug-入口"><a href="#Debug-入口" class="headerlink" title="Debug 入口"></a>Debug 入口</h3><p>控制平面自带的 <code>app/static/ai-chat</code> 页面（<code>app.js</code> + <code>index.html</code>）提供完整的调试面板，允许设定租户&#x2F;用户 ID、Idempotency Key、<code>/ai/runs</code> 请求、SSE 链接、<code>/input</code> 补发，并实时打印 native SSE 事件，便于调试流控与 overflow 行为。同时，Java 侧 <code>ruoyi-admin/src/main/resources/static/ai-chat</code> 也提供相似的前端，便于在 <code>ruoyi-admin</code> 部署环境中复盘 Java 与 Python 之间的 handoff。</p><h2 id="动态范式编排优化方案"><a href="#动态范式编排优化方案" class="headerlink" title="动态范式编排优化方案"></a>动态范式编排优化方案</h2><h3 id="方案概览：Intent-Router-Policy-Engine-Strategy-Executors-Runtime-Guard-Eval-闭环"><a href="#方案概览：Intent-Router-Policy-Engine-Strategy-Executors-Runtime-Guard-Eval-闭环" class="headerlink" title="方案概览：Intent Router + Policy Engine + Strategy Executors + Runtime Guard + Eval 闭环"></a>方案概览：Intent Router + Policy Engine + Strategy Executors + Runtime Guard + Eval 闭环</h3><p>当前控制平面已经具备基础事件存储与 MCP 通道，下一步就是将 Plan-and-Solve、ReAct 与 Reflection 映射到清晰的控制结构：</p><ul><li><strong>Intent Router</strong> 解析用户 query 的意图（直接对话、工具调用、打断等），并决定从哪条策略链（Plan&#x2F;Solve&#x2F;Reflect）进入。</li><li><strong>Policy Engine</strong> 在执行前判断租户&#x2F;工具&#x2F;安全策略（基于 <code>authz-lite</code>、<code>ai.tool.invoke</code> 日志等），在必要时拒绝、降级或走审计路径。</li><li><strong>Strategy Executors</strong> 包括 Plan（生成步骤）、Solve（调用 MCP）、Reflect（回顾证据与偏离），每个阶段都可携带上下文与前一次 evidence。</li><li><strong>Runtime Guard</strong> 引入预算、时延、失败率、证据冲突阈值，遇到越界则触发加固步骤（如降级到简单回答、请求人工介入或透传错误）。</li><li><strong>Eval 闭环</strong> 把 <code>step_trace/tool_trace/eval_metrics</code> 回写到 Policy Engine，进而驱动下一个 intent 的 routing。</li></ul><pre><code class=" mermaid">graph LR  Client[客户端 / 系统自动化]  API[Python 控制平面 API]  IntentRouter[Intent Router]  PolicyEngine[Policy Engine]  StrategyExec[Strategy Executors&lt;br/&gt;(Plan / Solve / Reflect)]  RuntimeGuard[Runtime Guard&lt;br/&gt;(预算/时延/失败率/证据冲突)]  EvalLoop[Eval 闭环&lt;br/&gt;Metrics + Feedback]  MCPClient[MCP Client]  JavaMCP[Java MCP 工具执行]  ToolAdaptors[Tool Adaptors + Registry]  Store[Run Store / Trace]  Client --&gt; API  API --&gt; IntentRouter  IntentRouter --&gt; PolicyEngine  PolicyEngine --&gt; StrategyExec  StrategyExec --&gt; RuntimeGuard  RuntimeGuard --&gt; EvalLoop  EvalLoop --&gt; PolicyEngine  StrategyExec --&gt; Store  StrategyExec --&gt; MCPClient  MCPClient --&gt; JavaMCP  JavaMCP --&gt; ToolAdaptors  Store --&gt; EvalLoop</code></pre><p>这个架构用图示明确分层：控制平面的 Intent Router 与 Policy Engine 共同决定是否进入 ReAct 或 Reflection，在 Strategy Executors 内形成 Plan-and-Solve 的闭环，Runtime Guard 保证 budget&#x2F;time&#x2F;failure&#x2F;证据冲突的安全开关，Eval Loop 负责收集数据并反馈给 Policy Engine 为下一步决策提供证据。</p><h3 id="状态机与切换条件"><a href="#状态机与切换条件" class="headerlink" title="状态机与切换条件"></a>状态机与切换条件</h3><p>为了让 Plan-and-Solve + ReAct + Reflection 的执行更加稳定，Run 需要一个状态机来驱动：</p><pre><code class=" mermaid">stateDiagram-v2    [*] --&gt; Idle    Idle --&gt; Planning : query / input 到达    Planning --&gt; Executing : policy_pass &amp;&amp; budget_ok    Executing --&gt; Monitoring : tool_call 或模型响应返回    Monitoring --&gt; Reflection : evidence_conflict / tool_failure_rate↑ / timeout    Monitoring --&gt; Completed : final_answer    Monitoring --&gt; Failed : repeated_errors / runtime_guard_abort    Reflection --&gt; Planning : reflection_success    Reflection --&gt; Escalation : manual_intervention_needed    Escalation --&gt; Idle : post-escalation</code></pre><ul><li><strong>预算</strong>：每个 run&#x2F;tenant 定义 <code>plan_budget</code>、<code>tool_budget</code>；超过预算表示手动复核。</li><li><strong>时延</strong>：<code>Runtime Guard</code> 监控 <code>tool_result</code> 的 P95 latency 与 SSE <code>final</code> 时间，若超过阈值则自动降级到 summary 模式。</li><li><strong>失败率</strong>：连续 <code>tool_result.ok=false</code> 超过配置次数会切到 <code>Reflection</code>，并在 <code>Eval</code> 中记录 error_code。</li><li><strong>证据冲突</strong>：当 Reflection 判断新 evidence 与既有 plan 冲突（比如 sensor 报告 vs 预测），即可重新进入 Planning，并触发安全提示或人工 review。</li></ul><h3 id="Plan-and-Solve-ReAct-Reflection-时序"><a href="#Plan-and-Solve-ReAct-Reflection-时序" class="headerlink" title="Plan-and-Solve &#x2F; ReAct &#x2F; Reflection 时序"></a>Plan-and-Solve &#x2F; ReAct &#x2F; Reflection 时序</h3><p>以下时序强调：用户 query -&gt; Planner -&gt; MCP 工具 -&gt; run trace -&gt; reflection -&gt; SSE 事件的闭环：</p><pre><code class=" mermaid">sequenceDiagram    participant User    participant API    participant Store    participant Orchestrator    participant Strategy    participant MCPClient    participant JavaMCP    participant Eval    User-&gt;&gt;API: POST /ai/runs (query)    API-&gt;&gt;Store: create_run + run_started    API-&gt;&gt;Orchestrator: enqueue    Orchestrator-&gt;&gt;Store: append user_message    Orchestrator-&gt;&gt;Strategy: plan_next_step (Plan)    Strategy--&gt;&gt;Eval: emit step_trace    Strategy-&gt;&gt;MCPClient: call_tool    MCPClient-&gt;&gt;JavaMCP: /tools/call    JavaMCP-&gt;&gt;Tool: execute    JavaMCP--&gt;&gt;MCPClient: tool_result    MCPClient-&gt;&gt;Strategy: return result    Strategy-&gt;&gt;Store: append tool_call/tool_result    Strategy-&gt;&gt;Eval: emit tool_trace + eval_metrics    Strategy-&gt;&gt;Orchestrator: decide next intent (Solve or Reflect)    Orchestrator-&gt;&gt;Store: final / run_failed    Store-&gt;&gt;API: SSE history + tail    Eval-&gt;&gt;Policy: update routing</code></pre><p>这个链路在 SSE 事件中已经可见（<code>user_message/tool_call/tool_result/final/run_failed</code>），但真正价值在于让 Strategy 在 Tool 结果后主动决定是否继续 <code>Solve</code>、退回 <code>Reflect</code>、或者终止 run。</p><h3 id="Eval-闭环与策略反馈"><a href="#Eval-闭环与策略反馈" class="headerlink" title="Eval 闭环与策略反馈"></a>Eval 闭环与策略反馈</h3><p>在 <code>Eval</code> 层，我们要记录如下指标，并将其反馈给 <code>Policy Engine</code> 与 <code>Runtime Guard</code>：</p><ul><li><strong>Run Trace</strong>（<code>run_events</code> 表，字段：<code>run_id/event_id/event_type/event_data/created_at</code>），支撑 SSE 重放与 audit。</li><li><strong>Step Trace</strong>（Strategy 输出的 <code>plan_id</code>, <code>intent</code>, <code>budget_used</code>, <code>score</code>），用于统计 ReAct vs Reflection 的占比。</li><li><strong>Tool Trace</strong>（每次 <code>tool_call</code> 的 tool name、args digest、latency、ok、preview），方便计算 <code>failure_rate</code> 与 <code>latency SLO</code>。</li><li><strong>Eval Metrics</strong>（如 <code>clarity_score</code>, <code>confidence</code>, <code>evidence_delta</code>, <code>cost_estimate</code>）供 Policy Engine 计算 routing 权重。</li></ul><pre><code class=" mermaid">graph TD    StrategyExec[Strategy Executors]    ToolTrace[Tool Trace]    EvalMetrics[Eval Metrics]    PolicyEngine[Policy Engine]    RuntimeGuard[Runtime Guard]    Store[Run Store]    StrategyExec --&gt; ToolTrace    ToolTrace --&gt; EvalMetrics    EvalMetrics --&gt; PolicyEngine    EvalMetrics --&gt; RuntimeGuard    PolicyEngine --&gt; StrategyExec    Store --&gt; EvalMetrics</code></pre><p>Eval Loop 实现后，Policy Engine 不再是静态规则，而是以证据为输入的自适应策略，能在不同策略链之间动态切换。</p><h3 id="数据与观测设计"><a href="#数据与观测设计" class="headerlink" title="数据与观测设计"></a>数据与观测设计</h3><ol><li><strong>Run Trace</strong>：<code>run_id</code> + <code>event_type</code> + <code>data</code> + <code>created_at</code>（<code>app/store.py</code> 中 <code>SQLiteRunStore.run_events</code>），用来驱动 SSE、run replay、审核与同步 <code>ai.tool.invoke</code> 日志。</li><li><strong>Step Trace</strong>：每个计划&#x2F;反思步骤写入 <code>RunStore</code> 的扩展字段（例如 <code>plan_id</code>, <code>type</code>, <code>budget_used</code>, <code>parent_intent</code>），方便事后分析 <code>Plan</code> vs <code>Reflect</code> 占比。</li><li><strong>Tool Trace</strong>：<code>tool_call/tool_result</code> 的 <code>data</code> 就是工具 trace，包含 <code>toolCallId</code>, <code>args</code>, <code>result</code>, <code>ok</code>, <code>preview</code>、<code>latencyMs</code>。结合 <code>ToolExecutor</code> 的 <code>invokeLogger</code>，可以拼接出跨语言的调用 timeline。</li><li><strong>Eval Metrics</strong>：收集 <code>clarity_score</code>（语言理解置信度）、<code>evidence_delta</code>（新数据与 plan 冲突程度）、<code>budget_left</code> 等指标，写入 <code>RunStore</code> 并通过 <code>EvalLoop</code> 反馈给 <code>Policy Engine</code>。</li></ol><p>所有这些数据都长期写在 <code>SQLiteRunStore</code>，未来可以用细粒度查询（<code>run_events</code> + <code>event_data</code>）构建 trace view，与 <code>ruoyi-admin</code> 的 <code>ai-chat</code> UI 结合，形成 debug+复盘平台。</p><h3 id="生产级灰度与回滚方案"><a href="#生产级灰度与回滚方案" class="headerlink" title="生产级灰度与回滚方案"></a>生产级灰度与回滚方案</h3><ol><li><strong>灰度方式</strong>：通过配置文件（如 <code>RUN_STORE_PROVIDER</code>、<code>MCP_BASE_URL</code>）在特定租户&#x2F;工厂上启用新版 <code>Intent Router + Policy</code> 组合；初期 1-2 个测试 tenant，收敛后逐步放大。</li><li><strong>观测指标</strong>：每次灰度都会同步观察 SSE event 异常率、<code>tool_result.ok=false</code> 比例、<code>Runtime Guard</code> 触发频次、<code>eval_metrics.conflict_score</code>，若任一指标在 5 分钟内超 1%，立即降级到 fallback 逻辑（如简单 echo 或 <code>final</code> 直接返回工具解释）。</li><li><strong>回滚方案</strong>：a) 在控制平面设置 <code>feature_flag</code> 使租户走旧逻辑；b) Java MCP 继续保留简单 poll-able <code>tool_call</code> 接口，确保新&#x2F;旧链路共存；c) 所有 run&#x2F;event 数据都在 <code>SQLiteRunStore</code>，即便回滚也可 replay 事件并复盘。</li><li><strong>演练机制</strong>：在灰度前后自动触发 <code>run</code> 补偿测试（POST <code>/ai/runs</code> + SSE + <code>/input</code>），记录 <code>run_id</code> 供后序复盘，确保 rollback 不会导致丢失工具状态。</li></ol><h3 id="面试亮点（STAR-叙事）"><a href="#面试亮点（STAR-叙事）" class="headerlink" title="面试亮点（STAR 叙事）"></a>面试亮点（STAR 叙事）</h3><ul><li><strong>Situation</strong>：纯 Java MCP 侧尝试做 Prompt+Tool 的同步流程，导致 run 实例不可追踪、工具超时难以隔离。</li><li><strong>Task</strong>：要在不破坏已有工具执行稳定性的前提下，交付一个可扩展、可观测、可灰度的控制平面。</li><li><strong>Action</strong>：我梳理出 Java entry + Python orchestrator 的边界，引入 <code>Intent Router -&gt; Policy Engine -&gt; Strategy Executors -&gt; Runtime Guard -&gt; Eval Loop</code> 结构，打通 Plan-and-Solve、ReAct、Reflection，并在 <code>app/store.py</code> 加入 run&#x2F;event 的可持久化队列与 SSE overflow 机制。</li><li><strong>Result</strong>：新的架构让 run 的生命周期具备状态机、事件 replay、工具调用追踪，灰度入口可以基于租户&#x2F;指标迅速启停，面试中强调的“动态范式驱动的可控性”获得面试官认可。</li></ul><h2 id="路线图与里程碑"><a href="#路线图与里程碑" class="headerlink" title="路线图与里程碑"></a>路线图与里程碑</h2><ul><li><strong>Milestone 0：观测与 trace 对齐</strong><ul><li>验收标准：<code>SQLiteRunStore</code> 已存储 <code>run_events</code>；<code>/ai/runs/&#123;runId&#125;/events</code> 支持 replay + overflow 通知；<code>ai-chat</code> UI 可复用事件。</li></ul></li><li><strong>Milestone 1：Intent Router + Policy Engine 就绪</strong><ul><li>验收标准：<code>Intent Router</code> 能识别 <code>tool:*</code> vs 普通 query，<code>Policy Engine</code> 在前置拒绝与降级策略上录了 <code>ai.tool.invoke</code> 日志，<code>Store</code> 写入 <code>step_trace</code>。</li></ul></li><li><strong>Milestone 2：Strategy Executors + Runtime Guard</strong><ul><li>验收标准：<code>Strategy Executors</code> 区分 Plan&#x2F;Solve&#x2F;Reflect，<code>Runtime Guard</code> 监控预算&#x2F;延迟&#x2F;失败，满足 <code>state machine</code> 中的 Monitoring 与 Reflection 触发条件。</li></ul></li><li><strong>Milestone 3：Eval 闭环与数据反馈</strong><ul><li>验收标准：工具 trace + eval metrics 写入 <code>RunStore</code>，Policy 能根据 <code>clarity_score</code>&#x2F;<code>evidence_delta</code> 调整 routing 策略，<code>Eval Loop</code> 触发 runtime guard。</li></ul></li><li><strong>Milestone 4：灰度 + 回滚 + 面试亮点复盘</strong><ul><li>验收标准：按租户灰度新功能、指标失效能自动降级、回滚演练记录在案，能够用 STAR 方式说清楚改进点。</li></ul></li></ul><h2 id="风险清单"><a href="#风险清单" class="headerlink" title="风险清单"></a>风险清单</h2><ul><li>协议漂移：Python 控制平面 <code>MCPClient</code> 如果缓存了旧的 <code>tools/list</code> schema，会导致 Java MCP <code>authz-lite</code> 拒绝。</li><li>Trace 膨胀：<code>run_events</code> 里写入冗余 <code>data</code> 可能让 SQLite file 迅速增长，需要定期归档。</li><li>Truth 残缺：Reflection 依赖 <code>evidence_delta</code>，如果数据进入延迟 &gt; 5s，反而导致过度回退。</li><li>黑天鹅：工具调用遇到 Kafka&#x2F;设备 API 降级，Runtime Guard 必须能快速截断而非无限重试。</li></ul><h2 id="反模式清单"><a href="#反模式清单" class="headerlink" title="反模式清单"></a>反模式清单</h2><ul><li>用 Java 直接硬编码策略开关，导致 Python 无法快速试验；</li><li>把 <code>Policy Engine</code> 写死在 <code>AiMcpToolDispatcher</code>，失去跨租户&#x2F;跨工具的自适应能力；</li><li>SSE&#x2F;Run Store 事件只保留内存，遇并发订阅泄漏 <code>SubscriberOverflow</code> 后找不到 trace；</li><li>把所有异常抛回 <code>final</code>，而不在 <code>Eval</code> 中打点、归类、提供证据冲突的上下文。</li></ul>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MCP</tag>
      
      <tag>ReAct</tag>
      
      <tag>Orchestrator</tag>
      
      <tag>AI工程</tag>
      
      <tag>Agent</tag>
      
      <tag>Plan-and-Solve</tag>
      
      <tag>Reflection</tag>
      
      <tag>架构分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>纯 Java AI vs Java MCP + Python Control Plane：重构方案与落地模块解析</title>
    <link href="/2026/02/20/java-ai-vs-java-mcp-python-control-plane/"/>
    <url>/2026/02/20/java-ai-vs-java-mcp-python-control-plane/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>第一版 AI 能力是典型的纯 Java 单体实现：请求进入 Java Web 层后，直接在同一进程内完成模型调用、工具路由、业务执行与响应拼装。这个方案早期上线快，但随着需求从「能用」走向「可控、可观测、可扩展」，问题开始集中暴露：</p><ol><li>推理编排和业务工具耦合，修改工具策略会影响主链路稳定性。</li><li>流式输出与长任务状态管理能力弱，<code>run</code> 生命周期缺少统一抽象。</li><li>多工具权限控制分散在业务代码里，审计链路不完整。</li><li>Java 侧迭代成本高，难以快速试验 Agent 策略和协议演进。</li></ol><p>因此本次重构目标不是简单“拆服务”，而是明确控制平面与执行平面的边界：<strong>Java 负责工具执行的稳定性与治理；Python 负责运行编排与流式交互体验</strong>。</p><h2 id="现状：纯-Java-AI-实现的结构与瓶颈"><a href="#现状：纯-Java-AI-实现的结构与瓶颈" class="headerlink" title="现状：纯 Java AI 实现的结构与瓶颈"></a>现状：纯 Java AI 实现的结构与瓶颈</h2><p>当前纯 Java 方案的主流程可以抽象为：</p><p><code>HTTP 请求 -&gt; Java Controller -&gt; Prompt/Tool 组装 -&gt; 模型调用 -&gt; 工具执行 -&gt; 返回结果</code></p><p>这个流程的问题不在“能否跑通”，而在于以下三个工程属性不足：</p><ol><li>生命周期治理不足：缺少 <code>run</code> 级状态机，失败恢复、断线重连、事件重放困难。</li><li>观测粒度不足：日志多为文本级，缺少标准化 <code>tool_call/tool_result</code> 事件和 trace 关联。</li><li>协议演进困难：工具调用协议与 Java 内部对象绑定，跨语言复用成本高。</li></ol><h2 id="关键差异对比表"><a href="#关键差异对比表" class="headerlink" title="关键差异对比表"></a>关键差异对比表</h2><table><thead><tr><th>维度</th><th>纯 Java AI（当前）</th><th>Java MCP + Python Control Plane（目标）</th><th>关键收益</th></tr></thead><tbody><tr><td>架构边界</td><td>编排与执行同进程</td><td>控制平面与执行平面分离</td><td>解耦迭代节奏</td></tr><tr><td>工具协议</td><td>内部对象&#x2F;方法调用为主</td><td>统一 MCP 协议 + tool registry</td><td>跨语言一致性</td></tr><tr><td>运行模型</td><td>请求级同步思维</td><td><code>run</code> 异步生命周期 + SSE 事件流</td><td>可恢复、可追踪</td></tr><tr><td>权限治理</td><td>业务代码内零散校验</td><td><code>authz-lite</code> 前置校验</td><td>风险收敛到入口</td></tr><tr><td>可观测性</td><td>文本日志为主</td><td>标准事件 + <code>ai.tool.invoke</code> 结构化日志</td><td>排障效率提升</td></tr><tr><td>扩展路径</td><td>增加工具需改主流程</td><td>registry 注册 + dispatcher 分发</td><td>新工具接入更快</td></tr><tr><td>失败处理</td><td>失败点分散</td><td>run 状态机 + 可回放事件流</td><td>故障定位更确定</td></tr><tr><td>研发效率</td><td>Java 改动链路长</td><td>Python 快速试验，Java 保持稳定内核</td><td>试验速度与稳定性兼得</td></tr></tbody></table><h2 id="目标架构图（文字图）"><a href="#目标架构图（文字图）" class="headerlink" title="目标架构图（文字图）"></a>目标架构图（文字图）</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs text">[Client/UI]<br>   |<br>   | HTTP POST /ai/runs<br>   v<br>[Python Control Plane]<br>  - Run API (/ai/runs)<br>  - Orchestrator (plan/step/retry)<br>  - SSE Stream (/ai/runs/&#123;id&#125;/events)<br>  - MCP Client<br>   |<br>   | MCP tool call<br>   v<br>[Java MCP Server]<br>  - MCP Entry<br>  - Tool Registry<br>  - Authz-lite<br>  - Dispatcher<br>  - Tool Adapters (domain services)<br>   |<br>   v<br>[Business Systems / DB / Device APIs]<br></code></pre></td></tr></table></figure><h2 id="调用链设计（端到端）"><a href="#调用链设计（端到端）" class="headerlink" title="调用链设计（端到端）"></a>调用链设计（端到端）</h2><ol><li>客户端提交问题到 Python <code>POST /ai/runs</code>，返回 <code>runId</code>（异步）。</li><li>Orchestrator 创建步骤并触发模型推理，决定是否调用工具。</li><li>若需工具，MCP Client 发起标准化 <code>tool_call</code> 到 Java MCP 入口。</li><li>Java 侧经 <code>registry -&gt; authz-lite -&gt; dispatcher</code> 找到目标工具并执行。</li><li>Java 产出 <code>ai.tool.invoke</code> 结构化日志与工具结果，返回 MCP 响应。</li><li>Python 将 <code>tool_result</code> 写入运行上下文，继续下一步推理。</li><li>SSE 端持续推送 <code>run_started / step / tool_call / tool_result / completed|failed</code>。</li></ol><p>这条调用链的关键是：<strong>控制平面只做编排，不承载业务副作用；执行平面只做可治理的工具执行，不绑推理策略。</strong></p><h2 id="模块拆分与职责"><a href="#模块拆分与职责" class="headerlink" title="模块拆分与职责"></a>模块拆分与职责</h2><h3 id="Java-侧（执行平面）"><a href="#Java-侧（执行平面）" class="headerlink" title="Java 侧（执行平面）"></a>Java 侧（执行平面）</h3><ol><li><code>mcp-entry</code>：协议入口、请求反序列化、trace 透传。</li><li><code>tool-registry</code>：工具元数据与 handler 注册，支持动态发现或配置注册。</li><li><code>authz-lite</code>：轻量权限校验（租户、角色、工具级 allowlist）。</li><li><code>dispatcher</code>：统一分发、超时控制、错误码标准化。</li><li><code>ai.tool.invoke</code> 日志：记录 <code>runId/toolName/argsDigest/latency/resultCode</code>，支持审计与性能分析。</li></ol><h3 id="Python-侧（控制平面）"><a href="#Python-侧（控制平面）" class="headerlink" title="Python 侧（控制平面）"></a>Python 侧（控制平面）</h3><ol><li><code>/ai/runs</code>：异步创建运行，立即返回 <code>runId</code>。</li><li><code>/ai/runs/&#123;runId&#125;/events</code>：SSE 事件流，支持重连后的 replay + tail。</li><li><code>orchestrator</code>：步骤状态机、重试策略、工具调用决策。</li><li><code>mcp-client</code>：与 Java MCP 协议通信、异常映射、幂等请求头传递。</li></ol><h2 id="已落地模块（本次盘点）"><a href="#已落地模块（本次盘点）" class="headerlink" title="已落地模块（本次盘点）"></a>已落地模块（本次盘点）</h2><p>目前已经看到并可归类为“已落地”的能力有：</p><ol><li>Java MCP 入口层（可接收 MCP tool 调用）。</li><li>Java tool registry（工具注册与查找能力）。</li><li>Java <code>authz-lite</code>（轻量授权校验链路）。</li><li>Java dispatcher（统一调度与执行入口）。</li><li>Java <code>ai.tool.invoke</code> 日志（工具调用审计关键埋点）。</li><li>Python <code>/ai/runs</code> + SSE 事件流接口骨架。</li><li>Python MCP client（控制平面到执行平面的协议桥接）。</li></ol><p>这意味着架构重构不是“纸面设计”，而是已经完成了核心骨架打通，后续重点转向稳定性与规范化。</p><h2 id="实施计划（阶段里程碑）"><a href="#实施计划（阶段里程碑）" class="headerlink" title="实施计划（阶段里程碑）"></a>实施计划（阶段里程碑）</h2><h3 id="Phase-1：协议与入口固化（已完成主体）"><a href="#Phase-1：协议与入口固化（已完成主体）" class="headerlink" title="Phase 1：协议与入口固化（已完成主体）"></a>Phase 1：协议与入口固化（已完成主体）</h3><p>目标：打通 Python -&gt; Java MCP 的最小闭环。<br>里程碑：</p><ol><li><code>POST /ai/runs</code> 创建 run。</li><li>Java MCP 入口可执行至少一个真实工具。</li><li>SSE 能看到 <code>tool_call/tool_result</code> 基础事件。</li></ol><h3 id="Phase-2：治理能力补齐"><a href="#Phase-2：治理能力补齐" class="headerlink" title="Phase 2：治理能力补齐"></a>Phase 2：治理能力补齐</h3><p>目标：把“能跑”升级为“可控”。<br>里程碑：</p><ol><li><code>authz-lite</code> 从静态规则升级到可配置策略。</li><li>dispatcher 增加超时分级与熔断隔离。</li><li><code>ai.tool.invoke</code> 接入统一 trace&#x2F;span 关联。</li></ol><h3 id="Phase-3：运行时可靠性"><a href="#Phase-3：运行时可靠性" class="headerlink" title="Phase 3：运行时可靠性"></a>Phase 3：运行时可靠性</h3><p>目标：把“可控”升级为“可恢复”。<br>里程碑：</p><ol><li>run 状态机补齐中断恢复与重试幂等。</li><li>SSE 支持断线续传与游标回放。</li><li>工具失败分类（可重试&#x2F;不可重试&#x2F;需人工干预）。</li></ol><h3 id="Phase-4：规模化扩展"><a href="#Phase-4：规模化扩展" class="headerlink" title="Phase 4：规模化扩展"></a>Phase 4：规模化扩展</h3><p>目标：低成本扩工具与跨团队协作。<br>里程碑：</p><ol><li>工具接入模板化（注册、鉴权、日志、测试用例）。</li><li>多租户策略隔离与限流策略下沉。</li><li>性能基准与容量模型稳定输出。</li></ol><h2 id="验收标准（Definition-of-Done）"><a href="#验收标准（Definition-of-Done）" class="headerlink" title="验收标准（Definition of Done）"></a>验收标准（Definition of Done）</h2><ol><li>功能正确性：核心业务工具在新链路调用成功率 &gt;&#x3D; 99.9%。</li><li>时延目标：P95 工具调用端到端时延 &lt;&#x3D; 800ms（不含大模型本体推理）。</li><li>可观测性：<code>runId</code> 能串联 API 日志、MCP 调用日志、错误事件。</li><li>稳定性：单工具故障不拖垮 run 主链路，错误可降级可回传。</li><li>回归保障：关键工具具备契约测试 + 冒烟测试 + 回滚演练记录。</li></ol><h2 id="面试亮点（架构师视角）"><a href="#面试亮点（架构师视角）" class="headerlink" title="面试亮点（架构师视角）"></a>面试亮点（架构师视角）</h2><ol><li><strong>控制平面&#x2F;执行平面分离</strong>：把“策略迭代快”与“执行稳定”矛盾拆开，组织协作效率显著提升。</li><li><strong>协议先行</strong>：MCP 将工具调用变成标准接口，降低语言与团队边界摩擦。</li><li><strong>run 生命周期建模</strong>：从“请求响应”升级到“可追踪任务”，天然支持 SSE、重放、恢复。</li><li><strong>治理内建而非补丁</strong>：<code>authz-lite + dispatcher + ai.tool.invoke</code> 在入口前置，风险可控可审计。</li><li><strong>渐进式重构</strong>：先打通骨架，再补治理和可靠性，避免大爆炸式改造风险。</li></ol><h2 id="风险与回滚策略"><a href="#风险与回滚策略" class="headerlink" title="风险与回滚策略"></a>风险与回滚策略</h2><h3 id="主要风险"><a href="#主要风险" class="headerlink" title="主要风险"></a>主要风险</h3><ol><li>双栈复杂度上升：Python 与 Java 边界如果定义不清，会形成新的耦合。</li><li>协议漂移：MCP schema 版本治理缺失会造成灰度失败。</li><li>观测碎片化：日志、事件、trace 口径不一致会影响排障。</li></ol><h3 id="回滚方案"><a href="#回滚方案" class="headerlink" title="回滚方案"></a>回滚方案</h3><ol><li><strong>流量级回滚</strong>：网关开关将特定租户&#x2F;场景切回纯 Java 旧链路。</li><li><strong>能力级回滚</strong>：按工具维度关闭 MCP 路由，仅保留白名单工具走新链路。</li><li><strong>版本级回滚</strong>：保持 Python orchestrator 与 Java MCP 的最近稳定版本镜像，可一键回退。</li><li><strong>数据级保障</strong>：run 事件与日志保留，回滚后仍可复盘失败路径。</li></ol><p>回滚原则：<strong>先止损再定位，先降级再修复</strong>。如果新链路在连续窗口内错误率超阈值（如 5 分钟 &gt; 1%），自动触发降级。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这次重构的价值不只是“多了一个 Python 服务”，而是建立了一个可持续演进的 AI 工程底座：<br>Java 守住执行稳定性与治理边界，Python 承担编排创新与交互体验。<br>在这个边界之上，未来接入更多工具、模型与业务场景都会更可控。</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Python</tag>
      
      <tag>AI工作日志</tag>
      
      <tag>MCP</tag>
      
      <tag>AI工程</tag>
      
      <tag>架构设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用 iPhone 远程操控 Mac：Termius + Tailscale + tmux（Codex 常驻）</title>
    <link href="/guides/termius-tailscale-tmux/"/>
    <url>/guides/termius-tailscale-tmux/</url>
    
    <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>用 iPhone 的 Termius 远程连接 Mac，借助 Tailscale 组网，实现随时随地安全 SSH；用 tmux 保持会话不断线（适合常驻跑 Codex）。</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ul><li>Termius：iOS SSH 客户端</li><li>Tailscale：内网组网（避免端口映射）</li><li>tmux：会话常驻</li></ul><h2 id="Mac：开启-SSH"><a href="#Mac：开启-SSH" class="headerlink" title="Mac：开启 SSH"></a>Mac：开启 SSH</h2><p>系统设置 → 通用 → 共享 → 远程登录（Remote Login）打开。</p><h2 id="Termius：生成-SSH-Key-并配置"><a href="#Termius：生成-SSH-Key-并配置" class="headerlink" title="Termius：生成 SSH Key 并配置"></a>Termius：生成 SSH Key 并配置</h2><ol><li>Termius → Keychain → + → Generate Key → Ed25519</li><li>复制 Public Key（ssh-ed25519 …）</li><li>Mac 追加到 <code>~/.ssh/authorized_keys</code>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">nano ~/.ssh/authorized_keys<br><span class="hljs-built_in">chmod</span> 700 ~/.ssh<br><span class="hljs-built_in">chmod</span> 600 ~/.ssh/authorized_keys<br></code></pre></td></tr></table></figure><h2 id="Tailscale：同账号组网"><a href="#Tailscale：同账号组网" class="headerlink" title="Tailscale：同账号组网"></a>Tailscale：同账号组网</h2><ul><li>Mac 安装并登录官方 Tailscale.app</li><li>iPhone 安装并登录 Tailscale，开启 VPN</li><li>记下 Mac 的 Tailscale IP（100.x.y.z）或 MagicDNS</li></ul><h2 id="Termius：添加-Host"><a href="#Termius：添加-Host" class="headerlink" title="Termius：添加 Host"></a>Termius：添加 Host</h2><ul><li>Host：Mac 的 100.x 或 MagicDNS</li><li>Port：22</li><li>Username：你的 macOS 用户名</li><li>Auth：选择 Key</li></ul><h2 id="tmux：保持会话"><a href="#tmux：保持会话" class="headerlink" title="tmux：保持会话"></a>tmux：保持会话</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install tmux<br>tmux new -As codex<br></code></pre></td></tr></table></figure><p>常用：<code>Ctrl-b</code> 后按 <code>d</code> 断开但保留会话。</p><h2 id="macOS-权限坑（Desktop：Operation-not-permitted）"><a href="#macOS-权限坑（Desktop：Operation-not-permitted）" class="headerlink" title="macOS 权限坑（Desktop：Operation not permitted）"></a>macOS 权限坑（Desktop：Operation not permitted）</h2><p>如果 SSH 会话访问 <code>~/Desktop</code> 报 <code>Operation not permitted</code>，这是 macOS 隐私保护。</p><ul><li>方案 1（推荐）：把工作目录放到 <code>~/Work</code> 而不是 Desktop</li><li>方案 2：系统设置 → 隐私与安全性 → 完全磁盘访问权限 → 添加 <code>/usr/sbin/sshd</code>，然后重新连接</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>工具技巧</tag>
      
      <tag>远程办公</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于 posthoc_nemenyi_friedman() 函数的一点思考</title>
    <link href="/2019/12/23/Nemenyi/"/>
    <url>/2019/12/23/Nemenyi/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Scikit-posthocs 这个库提供了许多 Post-hoc (后续检验) 的函数，Tukey Post-hoc, Nemenyi Post-hoc 等常见后续测试在这个库里都有相对应的实现，使用起来较为方便。</p><p>最近做的作业中要求使用 Friedman 测试和 Nemenyi 后续测试，来检验三个分类算法的精度是否有较大差异。于是博主使用了 Scikit-posthocs 的 <code>posthoc_nemenyi_friedman()</code> 函数。但在使用过程中我发现这个函数的返回值和我预想中的不一样，它返回了一个所谓的 P-values 矩阵，这个矩阵长这样：</p><img src="/img/nemenyi/006tNbRwgy1ga7dvvelsrj30n80agt9e.jpg" srcset="/img/loading.gif" alt="image-20191223225516040" style="zoom: 50%;" /><p>盲猜矩阵的每个 P-value 是用来和 𝛼 做比较的，但是比较的原则是怎样的呢？这个比较的结果和 Nemenyi 测试结果是怎样关联的呢？</p><p>于是查看了一下这个函数的<a href="https://scikit-posthocs.readthedocs.io/en/latest/generated/scikit_posthocs.posthoc_nemenyi_friedman/" target="_blank" rel="noopener">官方文档</a>，然而文档只说明了函数用法，并没有详细说明函数内部操作的具体流程，无法解除我的疑惑。好在这个库是开源的，于是博主研究了一下这个函数的<a href="https://github.com/maximtrp/scikit-posthocs/blob/master/scikit_posthocs/_posthocs.py" target="_blank" rel="noopener">源码</a>.</p><p>经过博主的一系列研究，最终发现</p><p><strong>这个矩阵中的 P-value 由算法两两比较而产生，用来与 α 做比较，如果 P-value &gt; α，则被比较的两个算法没有明显差异，如果 P-value &lt; α，则被比较的两个算法有明显差异 (Reject H0).</strong></p><p>下面是研究过程：</p><h2 id="Nemenyi-测试"><a href="#Nemenyi-测试" class="headerlink" title="Nemenyi 测试"></a>Nemenyi 测试</h2><p>在解释这个函数的流程之前，我们必须先熟稔 Nemenyi 测试的流程</p><p>根据西瓜书上的说明，Friedman 测试结果如果表明 “算法性能显著不同”，则需进行 Nemenyi 后续测试。书上所描述的 Nemenyi 测试流程是这样的:</p><ol><li><p>根据公式计算 <strong>Critical Difference (CD)</strong>，<em>q⍺</em> 可查表获得</p><img src="/img/nemenyi/006tNbRwgy1ga77qogt8oj30cs042t8t.jpg" srcset="/img/loading.gif" alt="image-20191223192242846" style="zoom: 50%;" /></li><li><p>将两个算法的平均序值的差 <strong>(Average Rank Difference, ARD)</strong>  和 CD 进行比较，如果 ARD &gt; CD，则两个算法的性能有明显差异。</p></li></ol><h2 id="函数源码解释"><a href="#函数源码解释" class="headerlink" title="函数源码解释"></a>函数源码解释</h2><p>由上述 Nemenyi 测试的解释可得，在西瓜书中， Nemenyi 测试的核心在于计算 CD, 并将其与 ARD 进行比较。然而研究源码之后，博主发现<code>posthoc_nemenyi_friedman()</code>的思路和上述流程迥然不同，十分清奇，值得一看。下面是该函数作者的思路：</p><ol><li><p>在 CD 公式中，由于 <em>k</em> 和 <em>N</em> 是恒定的，因此可知 <em>q⍺</em> 的值决定了 CD 的值，CD 与 <em>q⍺</em> 存在函数映射</p><img src="/img/nemenyi/006tNbRwgy1ga7ao5d5qsj30mk0323yn.jpg" srcset="/img/loading.gif" alt="image-20191223210403181" style="zoom: 67%;" /></li><li><p>由于 ARD 和 CD 是可比较的，意味着 ARD 可化成与 CD 相同的形式。</p></li></ol>   <img src="/img/nemenyi/006tNbRwgy1ga7ap9uxk9j30n202g0sw.jpg" srcset="/img/loading.gif" alt="image-20191223210508251" style="zoom:67%;" /><ol start="3"><li><p>对等式做变换得</p><img src="/img/nemenyi/006tNbRwgy1ga7b0ruy3uj30d203oaa1.jpg" srcset="/img/loading.gif" alt="image-20191223211611760" style="zoom:67%;" /></li><li><p>等式的左边可通过计算得出，将算出的 qβ 值代入<code>自由度 = infinity，样本数 = k的学生化极差分布(Studentized Range)</code>,即可得到 β，β 即为函数返回的 P-value，用于和 α 进行比较</p></li></ol><blockquote><p>西瓜书中解释道 “<em>q⍺</em> 是 Tukey 分布的临界值，在 R 语言中可通过<code>qtukey(1-𝛼, k, Inf) / sqrt(2)</code>计算”。其实就是在自由度 = infinity，样本数 = k ，的学生化极差分布 (Studentized Range) 中取 (1-⍺) 分位数的值，这个在源码中也有所体现。</p></blockquote><h2 id="函数源码"><a href="#函数源码" class="headerlink" title="函数源码"></a>函数源码</h2><p>添加了博主注释的函数源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">posthoc_nemenyi_friedman</span>(<span class="hljs-params">a, y_col=<span class="hljs-literal">None</span>, block_col=<span class="hljs-literal">None</span>, group_col=<span class="hljs-literal">None</span>, melted=<span class="hljs-literal">False</span>, sort=<span class="hljs-literal">False</span></span>):<br>    <span class="hljs-comment"># 计算 q-value 可理解为 qβ，和公式中的 q⍺ 对应</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">compare_stats</span>(<span class="hljs-params">i, j</span>):<br>        dif = np.<span class="hljs-built_in">abs</span>(R[groups[i]] - R[groups[j]])<br>        <span class="hljs-comment"># qβ = ARD / 公式中带根号的部分</span><br>        qval = dif / np.sqrt(k * (k + <span class="hljs-number">1.</span>) / (<span class="hljs-number">6.</span> * n))<br>        <span class="hljs-keyword">return</span> qval<br><br>    <span class="hljs-comment"># 将输入的矩阵转换为该库中定义的 block 格式</span><br>    x, _y_col, _group_col, _block_col = __convert_to_block_df(a, y_col, group_col, block_col, melted)<br>    x.sort_values(by=[_group_col, _block_col], ascending=<span class="hljs-literal">True</span>, inplace=<span class="hljs-literal">True</span>)<br>    x.dropna(inplace=<span class="hljs-literal">True</span>)<br><br>    groups = x[_group_col].unique()<br>    k = groups.size<br>    n = x[_block_col].unique().size<br><br>    x[<span class="hljs-string">&#x27;mat&#x27;</span>] = x.groupby(_block_col)[_y_col].rank()<br>    R = x.groupby(_group_col)[<span class="hljs-string">&#x27;mat&#x27;</span>].mean()<br><br>    vs = np.zeros((k, k))<br>    <span class="hljs-comment"># 原矩阵的列数（用于比较的算法个数）为 k</span><br>    <span class="hljs-comment"># 生成 k * k 的比较矩阵 M，并将其初始化为零矩阵</span><br>    combs = it.combinations(<span class="hljs-built_in">range</span>(k), <span class="hljs-number">2</span>)<br>    tri_upper = np.triu_indices(vs.shape[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>)<br>    tri_lower = np.tril_indices(vs.shape[<span class="hljs-number">0</span>], -<span class="hljs-number">1</span>)<br><br>    vs[:, :] = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 计算 M 中两两比较的 q-value</span><br>    <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> combs:<br>        vs[i, j] = compare_stats(i, j)<br><br>    vs *= np.sqrt(<span class="hljs-number">2.</span>)<br><br>    <span class="hljs-comment"># 把 qβ 代入到自由度 = infinity，样本数 = k 的 Studentized 分布中，得到 β</span><br>    <span class="hljs-comment"># 由此可以得出 P-value 结果矩阵实际上是算法两两比较，根据公式算出 qβ 里其中的 β 值</span><br>    vs[tri_upper] = psturng(vs[tri_upper], k, np.inf)<br>    vs[tri_lower] = vs.T[tri_lower]<br>    np.fill_diagonal(vs, -<span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">return</span> DataFrame(vs, index=groups, columns=groups)<br></code></pre></td></tr></table></figure><h2 id="函数用法"><a href="#函数用法" class="headerlink" title="函数用法"></a>函数用法</h2><h4 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h4><p><strong>描述：</strong>多个算法在不同数据集上的测试结果 (精度，F1值 …) 所构成的矩阵，例：</p><img src="/img/nemenyi/006tNbRwgy1ga5wpvzuxoj30xw0jawij.jpg" srcset="/img/loading.gif" alt="image-20191222161536827" style="zoom: 33%;" /><p><strong>格式：</strong>一个  <code>Array_like</code> 的数组 (Numpy 数组和二维列表都可以)，或者是 <code>DataFrame</code> 对象，（如果是 <code>DataFrame</code> ，则有更多的相关参数需要输入，详见<a href="https://scikit-posthocs.readthedocs.io/en/latest/generated/scikit_posthocs.posthoc_nemenyi_friedman/" target="_blank" rel="noopener">官方文档</a>）</p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p><strong>描述</strong>：由算法两两对比产生的 P-value <code>DataFrame</code>矩阵，用于与 alpha 进行比较。例：</p><img src="/img/nemenyi/006tNbRwgy1ga7dvvelsrj30n80agt9e.jpg" srcset="/img/loading.gif" alt="image-20191223225516040" style="zoom: 50%;" /><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>上述推导均为博主根据函数写法所得，如有谬误欢迎指证，感激不尽！</p>]]></content>
    
    
    
    <tags>
      
      <tag>知识沉淀</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自用的Mac小技巧</title>
    <link href="/2019/11/16/%25E8%2587%25AA%25E7%2594%25A8%25E7%259A%2584Mac%25E5%25B0%258F%25E6%258A%2580%25E5%25B7%25A7/"/>
    <url>/2019/11/16/%25E8%2587%25AA%25E7%2594%25A8%25E7%259A%2584Mac%25E5%25B0%258F%25E6%258A%2580%25E5%25B7%25A7/</url>
    
    <content type="html"><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h4 id="使用键盘快捷键来快速给文件添加-删除-标签："><a href="#使用键盘快捷键来快速给文件添加-删除-标签：" class="headerlink" title="使用键盘快捷键来快速给文件添加 /删除 标签："></a>使用键盘快捷键来快速给文件添加 /删除 标签：</h4><ul><li>添加标签: 选择文件，然后使用 Control-1 到 Control-7 来添加（或移除）个人收藏标签。</li><li>移除标签: 选择文件，使用 Control-0（零）会移除文件的所有标签。</li></ul><h4 id="设置在终端中启动各种-app-的命令"><a href="#设置在终端中启动各种-app-的命令" class="headerlink" title="设置在终端中启动各种 app 的命令"></a>设置在终端中启动各种 app 的命令</h4><p>以 Typora 为例：</p><ol><li><p>通过添加别名<code>ty</code>来快速启动 Typora。在 <code>~/.bash_profile</code> (这个文件好像要自己建) 中添加 <code>alias ty=&quot;open -a typora&quot;</code></p></li><li><p>添加完成后，执行<code>source ~/.bash_profile</code>(source [executable_file] = ./executable_file ), 就可以在命令行中用 <code>ty [filepath/filename]</code> 以快速用 Typora 打开并编辑文件</p></li></ol><h4 id="文本编辑类"><a href="#文本编辑类" class="headerlink" title="文本编辑类"></a>文本编辑类</h4><ol><li><p><strong>文字退格</strong>： TAB 右移，按 SHIFT+TAB 左移</p></li><li><p><strong>输入 ⍺，β，𝞬 等特殊字符</strong>：用（⌘⌃-Space）呼出 Mac emoji 输入框，搜索 alpha, beta 等想要的字符即可</p></li><li><p><strong>在 word 中输入数学公式</strong>：(‘’⌃’’ + ‘’=’’) 即可呼出word 公式编辑框，输入 LaTeX 公式即可</p></li></ol><h4 id="解决网络端口占用"><a href="#解决网络端口占用" class="headerlink" title="解决网络端口占用"></a>解决网络端口占用</h4><ol><li>查看是占用所需端口的进程：终端输入<code>lsof -i tcp:[port]</code> 将port换成被占用的端口(如：4000)，将会出现占用端口的进程信息。</li></ol><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g917abws8fj30zk02h762.jpg" srcset="/img/loading.gif" alt="查看占用端口的进程"  /><ol start="2"><li>Kill 进程：找到进程的PID,使用kill命令：<code>kill [PID]</code>（进程的PID，如71881），杀死对应的进程，这样所占端口就被释放啦</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>工具技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2019/11/15/hello-world/"/>
    <url>/2019/11/15/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
