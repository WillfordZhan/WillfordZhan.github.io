<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Dify 还是自研 RAG：铸造 MES/ERP 场景的架构共创与落地计划</title>
    <link href="/2026/02/20/dify-rag-mes-erp/"/>
    <url>/2026/02/20/dify-rag-mes-erp/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>这轮讨论的目标非常明确：在已经完成一轮 Python AI 控制面重构的基础上，快速集成铸造行业知识库能力，兼顾两件事：</p><ol><li>先做出可上线、可用的生产能力。</li><li>方案本身要有工程亮点，能成为 AI 工程师岗位面试中的核心项目叙事。</li></ol><p>场景约束也很典型：数据来源复杂（公众号、书籍、工艺参数文档、行业文档），知识密度高、噪声高，且业务同时涉及 MES 实时数据与行业知识问答。</p><h2 id="先给结论"><a href="#先给结论" class="headerlink" title="先给结论"></a>先给结论</h2><p>这类场景不建议纯二选一（只用 Dify 内置 KB，或一上来全自研）。</p><p>推荐路线是：</p><ol><li><strong>双线并行</strong>：Dify 与自研检索服务同时接入。</li><li><strong>能力分层</strong>：<ul><li>Dify 负责快速编排和业务流程试错。</li><li>自研 RAG 检索服务负责数据清洗、切分、召回、重排、评测等“效果上限”能力。</li></ul></li><li><strong>Agent 策略收敛</strong>：<ul><li>在线默认 <code>ReAct + 工具调用 + RAG</code>。</li><li><code>Plan-and-solve</code> 仅在复杂任务触发。</li><li><code>Reflection</code> 只在低置信度&#x2F;高风险场景触发，不全量开启。</li></ul></li></ol><p>一句话总结：<strong>用 Dify 赢速度，用自研检索赢上限。</strong></p><h2 id="为什么不是纯-Dify-或纯自研"><a href="#为什么不是纯-Dify-或纯自研" class="headerlink" title="为什么不是纯 Dify 或纯自研"></a>为什么不是纯 Dify 或纯自研</h2><h3 id="纯-Dify-内置知识库"><a href="#纯-Dify-内置知识库" class="headerlink" title="纯 Dify 内置知识库"></a>纯 Dify 内置知识库</h3><p>优点：上线最快。<br>短板：在高噪声行业语料中，后期检索质量和可控性容易触顶。</p><h3 id="纯自研全栈-RAG"><a href="#纯自研全栈-RAG" class="headerlink" title="纯自研全栈 RAG"></a>纯自研全栈 RAG</h3><p>优点：长期上限高，可控性强。<br>短板：首期周期长，工程和运维复杂度高，不符合“快出效果”目标。</p><h3 id="混合方案（推荐）"><a href="#混合方案（推荐）" class="headerlink" title="混合方案（推荐）"></a>混合方案（推荐）</h3><p>优点：首期快，长期可控，风险最低。<br>短板：需要做好契约治理和双链路观测，但这是可工程化解决的问题。</p><h2 id="我们讨论沉淀的-10-条-Q-A（决策版）"><a href="#我们讨论沉淀的-10-条-Q-A（决策版）" class="headerlink" title="我们讨论沉淀的 10 条 Q&amp;A（决策版）"></a>我们讨论沉淀的 10 条 Q&amp;A（决策版）</h2><h3 id="Q1：数据合规先不管，能不能先做？"><a href="#Q1：数据合规先不管，能不能先做？" class="headerlink" title="Q1：数据合规先不管，能不能先做？"></a>Q1：数据合规先不管，能不能先做？</h3><p>可以先做验证版，但建议保留文档来源和版本元数据，后续补治理时不会返工。</p><h3 id="Q2：如果增强效果需要上新基础设施，可以加吗？"><a href="#Q2：如果增强效果需要上新基础设施，可以加吗？" class="headerlink" title="Q2：如果增强效果需要上新基础设施，可以加吗？"></a>Q2：如果增强效果需要上新基础设施，可以加吗？</h3><p>可以。建议优先上支持混合检索的引擎（如 OpenSearch）。</p><h3 id="Q3：数据量"><a href="#Q3：数据量" class="headerlink" title="Q3：数据量 &lt;&#x3D; 20G，QPS 50~500，怎么设计？"></a>Q3：数据量 &lt;&#x3D; 20G，QPS 50~500，怎么设计？</h3><p>这个规模下，核心不在“能不能跑”，而在“高峰稳定和检索质量可回归”。需要缓存、分级策略和压测门禁。</p><h3 id="Q4：先用-Qwen-最强模型验证效果，后续再谈成本，是否可行？"><a href="#Q4：先用-Qwen-最强模型验证效果，后续再谈成本，是否可行？" class="headerlink" title="Q4：先用 Qwen 最强模型验证效果，后续再谈成本，是否可行？"></a>Q4：先用 Qwen 最强模型验证效果，后续再谈成本，是否可行？</h3><p>可行，且是正确顺序。先做质量上限验证，再做成本优化和模型分层。</p><h3 id="Q5：Reranker-私有部署和公有部署区别？"><a href="#Q5：Reranker-私有部署和公有部署区别？" class="headerlink" title="Q5：Reranker 私有部署和公有部署区别？"></a>Q5：Reranker 私有部署和公有部署区别？</h3><p>公有部署：上线快、质量通常更好、免运维，但有调用成本和外部延迟。<br>私有部署：数据与服务更可控，但你当前 <code>4核8G + 无GPU</code> 条件下吞吐会受限。<br>建议：<strong>先公有验证，后私有评估</strong>。</p><h3 id="Q6：ACL-是什么？"><a href="#Q6：ACL-是什么？" class="headerlink" title="Q6：ACL 是什么？"></a>Q6：ACL 是什么？</h3><p>ACL（Access Control List）是访问控制列表。<br>在 RAG 里就是“谁能检索到哪些文档&#x2F;片段”的硬约束，必须在召回阶段就生效。</p><h3 id="Q7：数据更新要分钟级，能支持吗？"><a href="#Q7：数据更新要分钟级，能支持吗？" class="headerlink" title="Q7：数据更新要分钟级，能支持吗？"></a>Q7：数据更新要分钟级，能支持吗？</h3><p>能。需要增量 ingest + upsert 索引 + 任务队列，避免全量重建。</p><h3 id="Q8：Dify-和自研双接入是否推荐？"><a href="#Q8：Dify-和自研双接入是否推荐？" class="headerlink" title="Q8：Dify 和自研双接入是否推荐？"></a>Q8：Dify 和自研双接入是否推荐？</h3><p>推荐。这正是当前阶段“快 + 稳 + 可扩展”的最优策略。</p><h3 id="Q9：什么是金标问答？为什么必须做？"><a href="#Q9：什么是金标问答？为什么必须做？" class="headerlink" title="Q9：什么是金标问答？为什么必须做？"></a>Q9：什么是金标问答？为什么必须做？</h3><p>金标问答不是 few-shot，它是评测基准集。<br>作用是客观评估“改了检索策略后是否真的变好”，避免调参靠感觉。</p><p>示例（非行业）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;qa_001&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;question&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;锅炉水质硬度超标会导致什么问题？&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;answerable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;expected_doc_ids&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;doc_chem_12&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;doc_ops_03&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;must_include_points&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;结垢风险&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;换热效率下降&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;能耗上升&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="Q10：低置信时策略怎么定？"><a href="#Q10：低置信时策略怎么定？" class="headerlink" title="Q10：低置信时策略怎么定？"></a>Q10：低置信时策略怎么定？</h3><p>采用“<strong>追问 + 带风险提示回答</strong>”。这是兼顾可用性与安全性的合理策略。</p><h2 id="生产落地建议（阶段化）"><a href="#生产落地建议（阶段化）" class="headerlink" title="生产落地建议（阶段化）"></a>生产落地建议（阶段化）</h2><h3 id="Phase-1：2-3-周，先跑通效果"><a href="#Phase-1：2-3-周，先跑通效果" class="headerlink" title="Phase 1：2~3 周，先跑通效果"></a>Phase 1：2~3 周，先跑通效果</h3><ol><li>建立最小 ingest pipeline（解析&#x2F;清洗&#x2F;切分&#x2F;元数据）。</li><li>上线 <code>Hybrid Retrieval</code>（关键词 + 向量）与基础过滤。</li><li>输出可引用证据（chunk&#x2F;doc 引用 ID）。</li></ol><h3 id="Phase-2：3-5-周，提升稳定性"><a href="#Phase-2：3-5-周，提升稳定性" class="headerlink" title="Phase 2：3~5 周，提升稳定性"></a>Phase 2：3~5 周，提升稳定性</h3><ol><li>加 reranker（按复杂度和置信度触发）。</li><li>建立分钟级增量更新链路。</li><li>建立缓存与限流，控制峰值时延。</li></ol><h3 id="Phase-3：5-8-周，工程化闭环"><a href="#Phase-3：5-8-周，工程化闭环" class="headerlink" title="Phase 3：5~8 周，工程化闭环"></a>Phase 3：5~8 周，工程化闭环</h3><ol><li>建立金标问答集和离线评测流水线。</li><li>对接 Dify External Knowledge API 与 Python Agent 双入口。</li><li>做回归门禁（Recall@K、citation 覆盖率、低置信策略命中率、P95 时延）。</li></ol><h2 id="面试亮点怎么讲"><a href="#面试亮点怎么讲" class="headerlink" title="面试亮点怎么讲"></a>面试亮点怎么讲</h2><p>这套项目建议按下面这条主线讲：</p><ol><li>我没有做“玩具 Agent”，而是做了“可运营 RAG 平台化能力”。</li><li>架构上用双通道解耦了“业务实时数据工具调用”和“行业知识检索问答”。</li><li>通过金标评测和回归门禁，把模型调优从“经验主义”变成“工程可验证”。</li><li>在资源受限（无 GPU）条件下，通过分级策略、缓存和路由，实现了效果与成本平衡。</li></ol><h2 id="最后一句"><a href="#最后一句" class="headerlink" title="最后一句"></a>最后一句</h2><p>在铸造 MES&#x2F;ERP 场景，真正决定成败的不是“Agent 名字有多花”，而是：</p><ol><li>数据管道质量。</li><li>检索与过滤设计。</li><li>评测和回归体系。</li></ol><p>先把这三件事做好，RAG 才会从 Demo 变成生产能力。</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI工程</tag>
      
      <tag>RAG</tag>
      
      <tag>Dify</tag>
      
      <tag>MCP</tag>
      
      <tag>架构设计</tag>
      
      <tag>知识库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>里程碑进展：Java AI 模块配置与依赖清理（MCP 版）</title>
    <link href="/2026/02/20/java-ai-mcp-cleanup-milestone/"/>
    <url>/2026/02/20/java-ai-mcp-cleanup-milestone/</url>
    
    <content type="html"><![CDATA[<h2 id="里程碑范围"><a href="#里程碑范围" class="headerlink" title="里程碑范围"></a>里程碑范围</h2><p>本次里程碑聚焦 Java 侧 AI 模块的“减法治理”：明确 MCP 方案的保留项，移除历史遗留配置与依赖，降低维护复杂度并收敛运行面。</p><h2 id="配置清理结果（YAML）"><a href="#配置清理结果（YAML）" class="headerlink" title="配置清理结果（YAML）"></a>配置清理结果（YAML）</h2><p>在本地 YAML 配置中，已完成 MCP-only 重构的配置收口：</p><ol><li>删除历史遗留且已废弃的配置段：<code>ai.model</code>、<code>ai.store</code>、<code>ai.prompt</code>、<code>ai.archive</code>。</li><li>保留当前仍在使用的配置段：<code>ai.mcp</code>、<code>ai.dify</code>。</li><li>结果：配置语义与当前架构一致，避免“看得见但不会生效”的伪配置继续干扰排查。</li></ol><h2 id="依赖清理结果（POM）"><a href="#依赖清理结果（POM）" class="headerlink" title="依赖清理结果（POM）"></a>依赖清理结果（POM）</h2><p>在 <code>pom</code> 依赖中，已完成未使用 legacy AI 依赖剔除：</p><ol><li>移除：<code>langchain4j-dashscope</code>、<code>langchain4j-open-ai</code>。</li><li>保留：<code>langchain4j</code> 核心能力（按当前实现需要）与 <code>dashscope-sdk-java</code>（在需要的位置继续使用）。</li><li>结果：依赖树更干净，后续升级与漏洞治理成本下降。</li></ol><h2 id="验证结论"><a href="#验证结论" class="headerlink" title="验证结论"></a>验证结论</h2><p>已执行编译验证命令并通过：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mvn -pl ruoyi-admin -am -DskipTests compile<br></code></pre></td></tr></table></figure><p>这说明本次“配置 + 依赖”清理在当前里程碑范围内未引入编译级回归。</p><h2 id="当前验收状态"><a href="#当前验收状态" class="headerlink" title="当前验收状态"></a>当前验收状态</h2><p>当前里程碑验收状态：<strong>已通过（范围内通过）</strong>。</p><p>说明：</p><ol><li>MCP 方向相关配置与依赖清理目标已达成。</li><li>编译链路已验证可通过。</li><li>全量测试基线仍存在历史遗留的无关失败项，本次不作为阻塞项。</li></ol><h2 id="下一步计划"><a href="#下一步计划" class="headerlink" title="下一步计划"></a>下一步计划</h2><ol><li>建立并收敛一版“可重复”的全量测试基线，先对历史失败做归因分层（本次改动相关 &#x2F; 无关）。</li><li>在 CI 中补充针对 AI 模块的最小回归检查（至少覆盖配置加载、关键 Bean 初始化、核心调用链烟测）。</li><li>持续推进 legacy 残留项扫描，避免后续分支再次引入已移除依赖或配置段。</li></ol>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI工程</tag>
      
      <tag>MCP</tag>
      
      <tag>Java</tag>
      
      <tag>里程碑</tag>
      
      <tag>依赖治理</tag>
      
      <tag>配置清理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>纯 Java AI vs Java MCP + Python Control Plane：重构方案与落地模块解析</title>
    <link href="/2026/02/20/java-ai-vs-java-mcp-python-control-plane/"/>
    <url>/2026/02/20/java-ai-vs-java-mcp-python-control-plane/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>第一版 AI 能力是典型的纯 Java 单体实现：请求进入 Java Web 层后，直接在同一进程内完成模型调用、工具路由、业务执行与响应拼装。这个方案早期上线快，但随着需求从「能用」走向「可控、可观测、可扩展」，问题开始集中暴露：</p><ol><li>推理编排和业务工具耦合，修改工具策略会影响主链路稳定性。</li><li>流式输出与长任务状态管理能力弱，<code>run</code> 生命周期缺少统一抽象。</li><li>多工具权限控制分散在业务代码里，审计链路不完整。</li><li>Java 侧迭代成本高，难以快速试验 Agent 策略和协议演进。</li></ol><p>因此本次重构目标不是简单“拆服务”，而是明确控制平面与执行平面的边界：<strong>Java 负责工具执行的稳定性与治理；Python 负责运行编排与流式交互体验</strong>。</p><h2 id="现状：纯-Java-AI-实现的结构与瓶颈"><a href="#现状：纯-Java-AI-实现的结构与瓶颈" class="headerlink" title="现状：纯 Java AI 实现的结构与瓶颈"></a>现状：纯 Java AI 实现的结构与瓶颈</h2><p>当前纯 Java 方案的主流程可以抽象为：</p><p><code>HTTP 请求 -&gt; Java Controller -&gt; Prompt/Tool 组装 -&gt; 模型调用 -&gt; 工具执行 -&gt; 返回结果</code></p><p>这个流程的问题不在“能否跑通”，而在于以下三个工程属性不足：</p><ol><li>生命周期治理不足：缺少 <code>run</code> 级状态机，失败恢复、断线重连、事件重放困难。</li><li>观测粒度不足：日志多为文本级，缺少标准化 <code>tool_call/tool_result</code> 事件和 trace 关联。</li><li>协议演进困难：工具调用协议与 Java 内部对象绑定，跨语言复用成本高。</li></ol><h2 id="关键差异对比表"><a href="#关键差异对比表" class="headerlink" title="关键差异对比表"></a>关键差异对比表</h2><table><thead><tr><th>维度</th><th>纯 Java AI（当前）</th><th>Java MCP + Python Control Plane（目标）</th><th>关键收益</th></tr></thead><tbody><tr><td>架构边界</td><td>编排与执行同进程</td><td>控制平面与执行平面分离</td><td>解耦迭代节奏</td></tr><tr><td>工具协议</td><td>内部对象&#x2F;方法调用为主</td><td>统一 MCP 协议 + tool registry</td><td>跨语言一致性</td></tr><tr><td>运行模型</td><td>请求级同步思维</td><td><code>run</code> 异步生命周期 + SSE 事件流</td><td>可恢复、可追踪</td></tr><tr><td>权限治理</td><td>业务代码内零散校验</td><td><code>authz-lite</code> 前置校验</td><td>风险收敛到入口</td></tr><tr><td>可观测性</td><td>文本日志为主</td><td>标准事件 + <code>ai.tool.invoke</code> 结构化日志</td><td>排障效率提升</td></tr><tr><td>扩展路径</td><td>增加工具需改主流程</td><td>registry 注册 + dispatcher 分发</td><td>新工具接入更快</td></tr><tr><td>失败处理</td><td>失败点分散</td><td>run 状态机 + 可回放事件流</td><td>故障定位更确定</td></tr><tr><td>研发效率</td><td>Java 改动链路长</td><td>Python 快速试验，Java 保持稳定内核</td><td>试验速度与稳定性兼得</td></tr></tbody></table><h2 id="目标架构图（文字图）"><a href="#目标架构图（文字图）" class="headerlink" title="目标架构图（文字图）"></a>目标架构图（文字图）</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs text">[Client/UI]<br>   |<br>   | HTTP POST /ai/runs<br>   v<br>[Python Control Plane]<br>  - Run API (/ai/runs)<br>  - Orchestrator (plan/step/retry)<br>  - SSE Stream (/ai/runs/&#123;id&#125;/events)<br>  - MCP Client<br>   |<br>   | MCP tool call<br>   v<br>[Java MCP Server]<br>  - MCP Entry<br>  - Tool Registry<br>  - Authz-lite<br>  - Dispatcher<br>  - Tool Adapters (domain services)<br>   |<br>   v<br>[Business Systems / DB / Device APIs]<br></code></pre></td></tr></table></figure><h2 id="调用链设计（端到端）"><a href="#调用链设计（端到端）" class="headerlink" title="调用链设计（端到端）"></a>调用链设计（端到端）</h2><ol><li>客户端提交问题到 Python <code>POST /ai/runs</code>，返回 <code>runId</code>（异步）。</li><li>Orchestrator 创建步骤并触发模型推理，决定是否调用工具。</li><li>若需工具，MCP Client 发起标准化 <code>tool_call</code> 到 Java MCP 入口。</li><li>Java 侧经 <code>registry -&gt; authz-lite -&gt; dispatcher</code> 找到目标工具并执行。</li><li>Java 产出 <code>ai.tool.invoke</code> 结构化日志与工具结果，返回 MCP 响应。</li><li>Python 将 <code>tool_result</code> 写入运行上下文，继续下一步推理。</li><li>SSE 端持续推送 <code>run_started / step / tool_call / tool_result / completed|failed</code>。</li></ol><p>这条调用链的关键是：<strong>控制平面只做编排，不承载业务副作用；执行平面只做可治理的工具执行，不绑推理策略。</strong></p><h2 id="模块拆分与职责"><a href="#模块拆分与职责" class="headerlink" title="模块拆分与职责"></a>模块拆分与职责</h2><h3 id="Java-侧（执行平面）"><a href="#Java-侧（执行平面）" class="headerlink" title="Java 侧（执行平面）"></a>Java 侧（执行平面）</h3><ol><li><code>mcp-entry</code>：协议入口、请求反序列化、trace 透传。</li><li><code>tool-registry</code>：工具元数据与 handler 注册，支持动态发现或配置注册。</li><li><code>authz-lite</code>：轻量权限校验（租户、角色、工具级 allowlist）。</li><li><code>dispatcher</code>：统一分发、超时控制、错误码标准化。</li><li><code>ai.tool.invoke</code> 日志：记录 <code>runId/toolName/argsDigest/latency/resultCode</code>，支持审计与性能分析。</li></ol><h3 id="Python-侧（控制平面）"><a href="#Python-侧（控制平面）" class="headerlink" title="Python 侧（控制平面）"></a>Python 侧（控制平面）</h3><ol><li><code>/ai/runs</code>：异步创建运行，立即返回 <code>runId</code>。</li><li><code>/ai/runs/&#123;runId&#125;/events</code>：SSE 事件流，支持重连后的 replay + tail。</li><li><code>orchestrator</code>：步骤状态机、重试策略、工具调用决策。</li><li><code>mcp-client</code>：与 Java MCP 协议通信、异常映射、幂等请求头传递。</li></ol><h2 id="已落地模块（本次盘点）"><a href="#已落地模块（本次盘点）" class="headerlink" title="已落地模块（本次盘点）"></a>已落地模块（本次盘点）</h2><p>目前已经看到并可归类为“已落地”的能力有：</p><ol><li>Java MCP 入口层（可接收 MCP tool 调用）。</li><li>Java tool registry（工具注册与查找能力）。</li><li>Java <code>authz-lite</code>（轻量授权校验链路）。</li><li>Java dispatcher（统一调度与执行入口）。</li><li>Java <code>ai.tool.invoke</code> 日志（工具调用审计关键埋点）。</li><li>Python <code>/ai/runs</code> + SSE 事件流接口骨架。</li><li>Python MCP client（控制平面到执行平面的协议桥接）。</li></ol><p>这意味着架构重构不是“纸面设计”，而是已经完成了核心骨架打通，后续重点转向稳定性与规范化。</p><h2 id="实施计划（阶段里程碑）"><a href="#实施计划（阶段里程碑）" class="headerlink" title="实施计划（阶段里程碑）"></a>实施计划（阶段里程碑）</h2><h3 id="Phase-1：协议与入口固化（已完成主体）"><a href="#Phase-1：协议与入口固化（已完成主体）" class="headerlink" title="Phase 1：协议与入口固化（已完成主体）"></a>Phase 1：协议与入口固化（已完成主体）</h3><p>目标：打通 Python -&gt; Java MCP 的最小闭环。<br>里程碑：</p><ol><li><code>POST /ai/runs</code> 创建 run。</li><li>Java MCP 入口可执行至少一个真实工具。</li><li>SSE 能看到 <code>tool_call/tool_result</code> 基础事件。</li></ol><h3 id="Phase-2：治理能力补齐"><a href="#Phase-2：治理能力补齐" class="headerlink" title="Phase 2：治理能力补齐"></a>Phase 2：治理能力补齐</h3><p>目标：把“能跑”升级为“可控”。<br>里程碑：</p><ol><li><code>authz-lite</code> 从静态规则升级到可配置策略。</li><li>dispatcher 增加超时分级与熔断隔离。</li><li><code>ai.tool.invoke</code> 接入统一 trace&#x2F;span 关联。</li></ol><h3 id="Phase-3：运行时可靠性"><a href="#Phase-3：运行时可靠性" class="headerlink" title="Phase 3：运行时可靠性"></a>Phase 3：运行时可靠性</h3><p>目标：把“可控”升级为“可恢复”。<br>里程碑：</p><ol><li>run 状态机补齐中断恢复与重试幂等。</li><li>SSE 支持断线续传与游标回放。</li><li>工具失败分类（可重试&#x2F;不可重试&#x2F;需人工干预）。</li></ol><h3 id="Phase-4：规模化扩展"><a href="#Phase-4：规模化扩展" class="headerlink" title="Phase 4：规模化扩展"></a>Phase 4：规模化扩展</h3><p>目标：低成本扩工具与跨团队协作。<br>里程碑：</p><ol><li>工具接入模板化（注册、鉴权、日志、测试用例）。</li><li>多租户策略隔离与限流策略下沉。</li><li>性能基准与容量模型稳定输出。</li></ol><h2 id="验收标准（Definition-of-Done）"><a href="#验收标准（Definition-of-Done）" class="headerlink" title="验收标准（Definition of Done）"></a>验收标准（Definition of Done）</h2><ol><li>功能正确性：核心业务工具在新链路调用成功率 &gt;&#x3D; 99.9%。</li><li>时延目标：P95 工具调用端到端时延 &lt;&#x3D; 800ms（不含大模型本体推理）。</li><li>可观测性：<code>runId</code> 能串联 API 日志、MCP 调用日志、错误事件。</li><li>稳定性：单工具故障不拖垮 run 主链路，错误可降级可回传。</li><li>回归保障：关键工具具备契约测试 + 冒烟测试 + 回滚演练记录。</li></ol><h2 id="面试亮点（架构师视角）"><a href="#面试亮点（架构师视角）" class="headerlink" title="面试亮点（架构师视角）"></a>面试亮点（架构师视角）</h2><ol><li><strong>控制平面&#x2F;执行平面分离</strong>：把“策略迭代快”与“执行稳定”矛盾拆开，组织协作效率显著提升。</li><li><strong>协议先行</strong>：MCP 将工具调用变成标准接口，降低语言与团队边界摩擦。</li><li><strong>run 生命周期建模</strong>：从“请求响应”升级到“可追踪任务”，天然支持 SSE、重放、恢复。</li><li><strong>治理内建而非补丁</strong>：<code>authz-lite + dispatcher + ai.tool.invoke</code> 在入口前置，风险可控可审计。</li><li><strong>渐进式重构</strong>：先打通骨架，再补治理和可靠性，避免大爆炸式改造风险。</li></ol><h2 id="风险与回滚策略"><a href="#风险与回滚策略" class="headerlink" title="风险与回滚策略"></a>风险与回滚策略</h2><h3 id="主要风险"><a href="#主要风险" class="headerlink" title="主要风险"></a>主要风险</h3><ol><li>双栈复杂度上升：Python 与 Java 边界如果定义不清，会形成新的耦合。</li><li>协议漂移：MCP schema 版本治理缺失会造成灰度失败。</li><li>观测碎片化：日志、事件、trace 口径不一致会影响排障。</li></ol><h3 id="回滚方案"><a href="#回滚方案" class="headerlink" title="回滚方案"></a>回滚方案</h3><ol><li><strong>流量级回滚</strong>：网关开关将特定租户&#x2F;场景切回纯 Java 旧链路。</li><li><strong>能力级回滚</strong>：按工具维度关闭 MCP 路由，仅保留白名单工具走新链路。</li><li><strong>版本级回滚</strong>：保持 Python orchestrator 与 Java MCP 的最近稳定版本镜像，可一键回退。</li><li><strong>数据级保障</strong>：run 事件与日志保留，回滚后仍可复盘失败路径。</li></ol><p>回滚原则：<strong>先止损再定位，先降级再修复</strong>。如果新链路在连续窗口内错误率超阈值（如 5 分钟 &gt; 1%），自动触发降级。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这次重构的价值不只是“多了一个 Python 服务”，而是建立了一个可持续演进的 AI 工程底座：<br>Java 守住执行稳定性与治理边界，Python 承担编排创新与交互体验。<br>在这个边界之上，未来接入更多工具、模型与业务场景都会更可控。</p>]]></content>
    
    
    
    <tags>
      
      <tag>AI工程</tag>
      
      <tag>MCP</tag>
      
      <tag>架构设计</tag>
      
      <tag>Java</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用 iPhone 远程操控 Mac：Termius + Tailscale + tmux（Codex 常驻）</title>
    <link href="/guides/termius-tailscale-tmux/"/>
    <url>/guides/termius-tailscale-tmux/</url>
    
    <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>用 iPhone 的 Termius 远程连接 Mac，借助 Tailscale 组网，实现随时随地安全 SSH；用 tmux 保持会话不断线（适合常驻跑 Codex）。</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ul><li>Termius：iOS SSH 客户端</li><li>Tailscale：内网组网（避免端口映射）</li><li>tmux：会话常驻</li></ul><h2 id="Mac：开启-SSH"><a href="#Mac：开启-SSH" class="headerlink" title="Mac：开启 SSH"></a>Mac：开启 SSH</h2><p>系统设置 → 通用 → 共享 → 远程登录（Remote Login）打开。</p><h2 id="Termius：生成-SSH-Key-并配置"><a href="#Termius：生成-SSH-Key-并配置" class="headerlink" title="Termius：生成 SSH Key 并配置"></a>Termius：生成 SSH Key 并配置</h2><ol><li>Termius → Keychain → + → Generate Key → Ed25519</li><li>复制 Public Key（ssh-ed25519 …）</li><li>Mac 追加到 <code>~/.ssh/authorized_keys</code>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">nano ~/.ssh/authorized_keys<br><span class="hljs-built_in">chmod</span> 700 ~/.ssh<br><span class="hljs-built_in">chmod</span> 600 ~/.ssh/authorized_keys<br></code></pre></td></tr></table></figure><h2 id="Tailscale：同账号组网"><a href="#Tailscale：同账号组网" class="headerlink" title="Tailscale：同账号组网"></a>Tailscale：同账号组网</h2><ul><li>Mac 安装并登录官方 Tailscale.app</li><li>iPhone 安装并登录 Tailscale，开启 VPN</li><li>记下 Mac 的 Tailscale IP（100.x.y.z）或 MagicDNS</li></ul><h2 id="Termius：添加-Host"><a href="#Termius：添加-Host" class="headerlink" title="Termius：添加 Host"></a>Termius：添加 Host</h2><ul><li>Host：Mac 的 100.x 或 MagicDNS</li><li>Port：22</li><li>Username：你的 macOS 用户名</li><li>Auth：选择 Key</li></ul><h2 id="tmux：保持会话"><a href="#tmux：保持会话" class="headerlink" title="tmux：保持会话"></a>tmux：保持会话</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install tmux<br>tmux new -As codex<br></code></pre></td></tr></table></figure><p>常用：<code>Ctrl-b</code> 后按 <code>d</code> 断开但保留会话。</p><h2 id="macOS-权限坑（Desktop：Operation-not-permitted）"><a href="#macOS-权限坑（Desktop：Operation-not-permitted）" class="headerlink" title="macOS 权限坑（Desktop：Operation not permitted）"></a>macOS 权限坑（Desktop：Operation not permitted）</h2><p>如果 SSH 会话访问 <code>~/Desktop</code> 报 <code>Operation not permitted</code>，这是 macOS 隐私保护。</p><ul><li>方案 1（推荐）：把工作目录放到 <code>~/Work</code> 而不是 Desktop</li><li>方案 2：系统设置 → 隐私与安全性 → 完全磁盘访问权限 → 添加 <code>/usr/sbin/sshd</code>，然后重新连接</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>工具技巧</tag>
      
      <tag>远程办公</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于 posthoc_nemenyi_friedman() 函数的一点思考</title>
    <link href="/2019/12/23/Nemenyi/"/>
    <url>/2019/12/23/Nemenyi/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Scikit-posthocs 这个库提供了许多 Post-hoc (后续检验) 的函数，Tukey Post-hoc, Nemenyi Post-hoc 等常见后续测试在这个库里都有相对应的实现，使用起来较为方便。</p><p>最近做的作业中要求使用 Friedman 测试和 Nemenyi 后续测试，来检验三个分类算法的精度是否有较大差异。于是博主使用了 Scikit-posthocs 的 <code>posthoc_nemenyi_friedman()</code> 函数。但在使用过程中我发现这个函数的返回值和我预想中的不一样，它返回了一个所谓的 P-values 矩阵，这个矩阵长这样：</p><img src="/img/nemenyi/006tNbRwgy1ga7dvvelsrj30n80agt9e.jpg" srcset="/img/loading.gif" alt="image-20191223225516040" style="zoom: 50%;" /><p>盲猜矩阵的每个 P-value 是用来和 𝛼 做比较的，但是比较的原则是怎样的呢？这个比较的结果和 Nemenyi 测试结果是怎样关联的呢？</p><p>于是查看了一下这个函数的<a href="https://scikit-posthocs.readthedocs.io/en/latest/generated/scikit_posthocs.posthoc_nemenyi_friedman/" target="_blank" rel="noopener">官方文档</a>，然而文档只说明了函数用法，并没有详细说明函数内部操作的具体流程，无法解除我的疑惑。好在这个库是开源的，于是博主研究了一下这个函数的<a href="https://github.com/maximtrp/scikit-posthocs/blob/master/scikit_posthocs/_posthocs.py" target="_blank" rel="noopener">源码</a>.</p><p>经过博主的一系列研究，最终发现</p><p><strong>这个矩阵中的 P-value 由算法两两比较而产生，用来与 α 做比较，如果 P-value &gt; α，则被比较的两个算法没有明显差异，如果 P-value &lt; α，则被比较的两个算法有明显差异 (Reject H0).</strong></p><p>下面是研究过程：</p><h2 id="Nemenyi-测试"><a href="#Nemenyi-测试" class="headerlink" title="Nemenyi 测试"></a>Nemenyi 测试</h2><p>在解释这个函数的流程之前，我们必须先熟稔 Nemenyi 测试的流程</p><p>根据西瓜书上的说明，Friedman 测试结果如果表明 “算法性能显著不同”，则需进行 Nemenyi 后续测试。书上所描述的 Nemenyi 测试流程是这样的:</p><ol><li><p>根据公式计算 <strong>Critical Difference (CD)</strong>，<em>q⍺</em> 可查表获得</p><img src="/img/nemenyi/006tNbRwgy1ga77qogt8oj30cs042t8t.jpg" srcset="/img/loading.gif" alt="image-20191223192242846" style="zoom: 50%;" /></li><li><p>将两个算法的平均序值的差 <strong>(Average Rank Difference, ARD)</strong>  和 CD 进行比较，如果 ARD &gt; CD，则两个算法的性能有明显差异。</p></li></ol><h2 id="函数源码解释"><a href="#函数源码解释" class="headerlink" title="函数源码解释"></a>函数源码解释</h2><p>由上述 Nemenyi 测试的解释可得，在西瓜书中， Nemenyi 测试的核心在于计算 CD, 并将其与 ARD 进行比较。然而研究源码之后，博主发现<code>posthoc_nemenyi_friedman()</code>的思路和上述流程迥然不同，十分清奇，值得一看。下面是该函数作者的思路：</p><ol><li><p>在 CD 公式中，由于 <em>k</em> 和 <em>N</em> 是恒定的，因此可知 <em>q⍺</em> 的值决定了 CD 的值，CD 与 <em>q⍺</em> 存在函数映射</p><img src="/img/nemenyi/006tNbRwgy1ga7ao5d5qsj30mk0323yn.jpg" srcset="/img/loading.gif" alt="image-20191223210403181" style="zoom: 67%;" /></li><li><p>由于 ARD 和 CD 是可比较的，意味着 ARD 可化成与 CD 相同的形式。</p></li></ol>   <img src="/img/nemenyi/006tNbRwgy1ga7ap9uxk9j30n202g0sw.jpg" srcset="/img/loading.gif" alt="image-20191223210508251" style="zoom:67%;" /><ol start="3"><li><p>对等式做变换得</p><img src="/img/nemenyi/006tNbRwgy1ga7b0ruy3uj30d203oaa1.jpg" srcset="/img/loading.gif" alt="image-20191223211611760" style="zoom:67%;" /></li><li><p>等式的左边可通过计算得出，将算出的 qβ 值代入<code>自由度 = infinity，样本数 = k的学生化极差分布(Studentized Range)</code>,即可得到 β，β 即为函数返回的 P-value，用于和 α 进行比较</p></li></ol><blockquote><p>西瓜书中解释道 “<em>q⍺</em> 是 Tukey 分布的临界值，在 R 语言中可通过<code>qtukey(1-𝛼, k, Inf) / sqrt(2)</code>计算”。其实就是在自由度 = infinity，样本数 = k ，的学生化极差分布 (Studentized Range) 中取 (1-⍺) 分位数的值，这个在源码中也有所体现。</p></blockquote><h2 id="函数源码"><a href="#函数源码" class="headerlink" title="函数源码"></a>函数源码</h2><p>添加了博主注释的函数源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">posthoc_nemenyi_friedman</span>(<span class="hljs-params">a, y_col=<span class="hljs-literal">None</span>, block_col=<span class="hljs-literal">None</span>, group_col=<span class="hljs-literal">None</span>, melted=<span class="hljs-literal">False</span>, sort=<span class="hljs-literal">False</span></span>):<br>    <span class="hljs-comment"># 计算 q-value 可理解为 qβ，和公式中的 q⍺ 对应</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">compare_stats</span>(<span class="hljs-params">i, j</span>):<br>        dif = np.<span class="hljs-built_in">abs</span>(R[groups[i]] - R[groups[j]])<br>        <span class="hljs-comment"># qβ = ARD / 公式中带根号的部分</span><br>        qval = dif / np.sqrt(k * (k + <span class="hljs-number">1.</span>) / (<span class="hljs-number">6.</span> * n))<br>        <span class="hljs-keyword">return</span> qval<br><br>    <span class="hljs-comment"># 将输入的矩阵转换为该库中定义的 block 格式</span><br>    x, _y_col, _group_col, _block_col = __convert_to_block_df(a, y_col, group_col, block_col, melted)<br>    x.sort_values(by=[_group_col, _block_col], ascending=<span class="hljs-literal">True</span>, inplace=<span class="hljs-literal">True</span>)<br>    x.dropna(inplace=<span class="hljs-literal">True</span>)<br><br>    groups = x[_group_col].unique()<br>    k = groups.size<br>    n = x[_block_col].unique().size<br><br>    x[<span class="hljs-string">&#x27;mat&#x27;</span>] = x.groupby(_block_col)[_y_col].rank()<br>    R = x.groupby(_group_col)[<span class="hljs-string">&#x27;mat&#x27;</span>].mean()<br><br>    vs = np.zeros((k, k))<br>    <span class="hljs-comment"># 原矩阵的列数（用于比较的算法个数）为 k</span><br>    <span class="hljs-comment"># 生成 k * k 的比较矩阵 M，并将其初始化为零矩阵</span><br>    combs = it.combinations(<span class="hljs-built_in">range</span>(k), <span class="hljs-number">2</span>)<br>    tri_upper = np.triu_indices(vs.shape[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>)<br>    tri_lower = np.tril_indices(vs.shape[<span class="hljs-number">0</span>], -<span class="hljs-number">1</span>)<br><br>    vs[:, :] = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 计算 M 中两两比较的 q-value</span><br>    <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> combs:<br>        vs[i, j] = compare_stats(i, j)<br><br>    vs *= np.sqrt(<span class="hljs-number">2.</span>)<br><br>    <span class="hljs-comment"># 把 qβ 代入到自由度 = infinity，样本数 = k 的 Studentized 分布中，得到 β</span><br>    <span class="hljs-comment"># 由此可以得出 P-value 结果矩阵实际上是算法两两比较，根据公式算出 qβ 里其中的 β 值</span><br>    vs[tri_upper] = psturng(vs[tri_upper], k, np.inf)<br>    vs[tri_lower] = vs.T[tri_lower]<br>    np.fill_diagonal(vs, -<span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">return</span> DataFrame(vs, index=groups, columns=groups)<br></code></pre></td></tr></table></figure><h2 id="函数用法"><a href="#函数用法" class="headerlink" title="函数用法"></a>函数用法</h2><h4 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h4><p><strong>描述：</strong>多个算法在不同数据集上的测试结果 (精度，F1值 …) 所构成的矩阵，例：</p><img src="/img/nemenyi/006tNbRwgy1ga5wpvzuxoj30xw0jawij.jpg" srcset="/img/loading.gif" alt="image-20191222161536827" style="zoom: 33%;" /><p><strong>格式：</strong>一个  <code>Array_like</code> 的数组 (Numpy 数组和二维列表都可以)，或者是 <code>DataFrame</code> 对象，（如果是 <code>DataFrame</code> ，则有更多的相关参数需要输入，详见<a href="https://scikit-posthocs.readthedocs.io/en/latest/generated/scikit_posthocs.posthoc_nemenyi_friedman/" target="_blank" rel="noopener">官方文档</a>）</p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p><strong>描述</strong>：由算法两两对比产生的 P-value <code>DataFrame</code>矩阵，用于与 alpha 进行比较。例：</p><img src="/img/nemenyi/006tNbRwgy1ga7dvvelsrj30n80agt9e.jpg" srcset="/img/loading.gif" alt="image-20191223225516040" style="zoom: 50%;" /><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>上述推导均为博主根据函数写法所得，如有谬误欢迎指证，感激不尽！</p>]]></content>
    
    
    
    <tags>
      
      <tag>知识沉淀</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自用的Mac小技巧</title>
    <link href="/2019/11/16/%25E8%2587%25AA%25E7%2594%25A8%25E7%259A%2584Mac%25E5%25B0%258F%25E6%258A%2580%25E5%25B7%25A7/"/>
    <url>/2019/11/16/%25E8%2587%25AA%25E7%2594%25A8%25E7%259A%2584Mac%25E5%25B0%258F%25E6%258A%2580%25E5%25B7%25A7/</url>
    
    <content type="html"><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h4 id="使用键盘快捷键来快速给文件添加-删除-标签："><a href="#使用键盘快捷键来快速给文件添加-删除-标签：" class="headerlink" title="使用键盘快捷键来快速给文件添加 /删除 标签："></a>使用键盘快捷键来快速给文件添加 /删除 标签：</h4><ul><li>添加标签: 选择文件，然后使用 Control-1 到 Control-7 来添加（或移除）个人收藏标签。</li><li>移除标签: 选择文件，使用 Control-0（零）会移除文件的所有标签。</li></ul><h4 id="设置在终端中启动各种-app-的命令"><a href="#设置在终端中启动各种-app-的命令" class="headerlink" title="设置在终端中启动各种 app 的命令"></a>设置在终端中启动各种 app 的命令</h4><p>以 Typora 为例：</p><ol><li><p>通过添加别名<code>ty</code>来快速启动 Typora。在 <code>~/.bash_profile</code> (这个文件好像要自己建) 中添加 <code>alias ty=&quot;open -a typora&quot;</code></p></li><li><p>添加完成后，执行<code>source ~/.bash_profile</code>(source [executable_file] = ./executable_file ), 就可以在命令行中用 <code>ty [filepath/filename]</code> 以快速用 Typora 打开并编辑文件</p></li></ol><h4 id="文本编辑类"><a href="#文本编辑类" class="headerlink" title="文本编辑类"></a>文本编辑类</h4><ol><li><p><strong>文字退格</strong>： TAB 右移，按 SHIFT+TAB 左移</p></li><li><p><strong>输入 ⍺，β，𝞬 等特殊字符</strong>：用（⌘⌃-Space）呼出 Mac emoji 输入框，搜索 alpha, beta 等想要的字符即可</p></li><li><p><strong>在 word 中输入数学公式</strong>：(‘’⌃’’ + ‘’=’’) 即可呼出word 公式编辑框，输入 LaTeX 公式即可</p></li></ol><h4 id="解决网络端口占用"><a href="#解决网络端口占用" class="headerlink" title="解决网络端口占用"></a>解决网络端口占用</h4><ol><li>查看是占用所需端口的进程：终端输入<code>lsof -i tcp:[port]</code> 将port换成被占用的端口(如：4000)，将会出现占用端口的进程信息。</li></ol><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g917abws8fj30zk02h762.jpg" srcset="/img/loading.gif" alt="查看占用端口的进程"  /><ol start="2"><li>Kill 进程：找到进程的PID,使用kill命令：<code>kill [PID]</code>（进程的PID，如71881），杀死对应的进程，这样所占端口就被释放啦</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>工具技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2019/11/15/hello-world/"/>
    <url>/2019/11/15/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
